<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha Signals - Nexxore</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }

        /* Navbar */
        .navbar {
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
        }

        .nav-links {
            display: flex;
            gap: 1rem;
        }

        .nav-links a {
            padding: 0.5rem 1rem;
            border-radius: 8px;
            text-decoration: none;
            color: #888;
            transition: all 0.2s;
        }

        .nav-links a:hover, .nav-links a.active {
            color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.8rem;
            background: linear-gradient(90deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        button {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            color: #0a0a1a;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #ff6b6b);
            color: #fff;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
        }

        .stat-card label {
            display: block;
            color: #888;
            font-size: 0.8rem;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .stat-card .value {
            font-size: 1.8rem;
            font-weight: bold;
        }

        .stat-card .value.positive { color: #00ff88; }
        .stat-card .value.negative { color: #ff4444; }
        .stat-card .value.neutral { color: #00d4ff; }

        .stat-card .subtext {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.25rem;
        }

        /* Main Layout */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 1.5rem;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Card Styles */
        .card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .card h2 {
            font-size: 1.1rem;
            color: #00d4ff;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .tab.active {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
        }

        /* Signal List */
        .signal-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .signal-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border-left: 4px solid;
            transition: transform 0.2s;
        }

        .signal-item:hover {
            transform: translateX(4px);
        }

        .signal-item.high-score { border-color: #00ff88; }
        .signal-item.medium-score { border-color: #ffaa00; }
        .signal-item.low-score { border-color: #ff4444; }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .signal-protocol {
            font-weight: 600;
            color: #fff;
        }

        .signal-score {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            padding: 0.2rem 0.6rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .signal-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: #888;
        }

        .signal-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .signal-actions button {
            padding: 0.4rem 0.8rem;
            font-size: 0.75rem;
        }

        /* Position List */
        .position-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.75rem;
        }

        .position-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .position-pnl {
            font-weight: 700;
            font-size: 1.1rem;
        }

        .position-pnl.positive { color: #00ff88; }
        .position-pnl.negative { color: #ff4444; }

        .position-details {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-top: 0.75rem;
            font-size: 0.8rem;
        }

        .position-details div {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.5rem;
            border-radius: 6px;
        }

        .position-details label {
            display: block;
            color: #666;
            font-size: 0.7rem;
            margin-bottom: 0.2rem;
        }

        /* Performance Chart */
        .chart-container {
            position: relative;
            height: 250px;
        }

        /* Strategy Performance */
        .strategy-grid {
            display: grid;
            gap: 0.75rem;
        }

        .strategy-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .strategy-name {
            font-weight: 500;
            text-transform: capitalize;
        }

        .strategy-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #00ff88;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Status Badge */
        .badge {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge.active { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .badge.executed { background: rgba(0, 212, 255, 0.2); color: #00d4ff; }
        .badge.expired { background: rgba(255, 68, 68, 0.2); color: #ff4444; }
        .badge.open { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .badge.closed { background: rgba(136, 136, 136, 0.2); color: #888; }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        .empty-state svg {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Status Banner */
        .status-banner {
            padding: 0.75rem 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        .status-banner.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        .status-banner.error {
            background: rgba(255, 68, 68, 0.1);
            border: 1px solid rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }
        .status-banner.info {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #00d4ff;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9rem;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Signal Reasoning */
        .signal-reasoning {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            font-size: 0.8rem;
            color: #aaa;
            line-height: 1.4;
        }

        /* Position Badge Types */
        .badge.long { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .badge.short { background: rgba(255, 136, 0, 0.2); color: #ff8800; }
        .badge.buy { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .badge.strong-buy { background: rgba(0, 255, 136, 0.35); color: #00ff88; font-weight: 700; }
        .badge.sell { background: rgba(255, 68, 68, 0.2); color: #ff4444; }
        .badge.strong-sell { background: rgba(255, 68, 68, 0.35); color: #ff4444; font-weight: 700; }
        .badge.hold { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }
        .badge.watch { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }
        .badge.low { background: rgba(0, 255, 136, 0.2); color: #00ff88; }
        .badge.medium { background: rgba(255, 170, 0, 0.2); color: #ffaa00; }
        .badge.high { background: rgba(255, 68, 68, 0.2); color: #ff4444; }

        /* P&L colors in text */
        .positive { color: #00ff88 !important; }
        .negative { color: #ff4444 !important; }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <a href="index.html" class="nav-brand">nexxore</a>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="research.html">Research</a>
            <a href="signals-dashboard.html" class="active">Signals</a>
            <a href="safe-yield.html">Safe Yield</a>
            <a href="vault-test.html">Vault Test</a>
        </div>
    </nav>

    <div class="container">
        <!-- Status Banner -->
        <div id="statusBanner" class="status-banner info" style="display: none;"></div>

        <header>
            <h1>üìä Alpha Signals Dashboard</h1>
            <div class="header-actions">
                <button class="btn-secondary" onclick="fetchLiveSignals()">üîç Fetch Signals</button>
                <button class="btn-secondary" onclick="refreshData()">üîÑ Refresh</button>
                <button class="btn-primary" onclick="autoExecuteSignals()">‚ö° Auto-Execute</button>
                <button class="btn-danger" onclick="resetPortfolio()">üóëÔ∏è Reset</button>
            </div>
        </header>

        <!-- Stats Overview -->
        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <label>Portfolio Value</label>
                <div class="value neutral" id="portfolioValue">$0</div>
                <div class="subtext" id="portfolioPnl">-</div>
            </div>
            <div class="stat-card">
                <label>Total P&L</label>
                <div class="value" id="totalPnl">$0</div>
                <div class="subtext" id="totalPnlPct">0%</div>
            </div>
            <div class="stat-card">
                <label>Win Rate</label>
                <div class="value neutral" id="winRate">0%</div>
                <div class="subtext" id="winLossCount">0W / 0L</div>
            </div>
            <div class="stat-card">
                <label>Active Signals</label>
                <div class="value neutral" id="activeSignals">0</div>
                <div class="subtext" id="totalSignals">0 total</div>
            </div>
            <div class="stat-card">
                <label>Open Positions</label>
                <div class="value neutral" id="openPositions">0</div>
                <div class="subtext" id="unrealizedPnl">$0 unrealized</div>
            </div>
            <div class="stat-card">
                <label>Profit Factor</label>
                <div class="value neutral" id="profitFactor">0.00</div>
                <div class="subtext" id="sharpeRatio">Sharpe: 0</div>
            </div>
        </div>

        <div class="main-grid">
            <!-- Left Column -->
            <div class="left-column">
                <!-- Signals Card -->
                <div class="card">
                    <h2>üéØ Alpha Signals</h2>
                    <div class="tabs">
                        <button class="tab active" data-tab="active" onclick="switchTab('active')">Active</button>
                        <button class="tab" data-tab="executed" onclick="switchTab('executed')">Executed</button>
                        <button class="tab" data-tab="all" onclick="switchTab('all')">All</button>
                    </div>
                    <div class="signal-list" id="signalList">
                        <div class="loading">Loading signals...</div>
                    </div>
                </div>

                <!-- Positions Card -->
                <div class="card">
                    <h2>üíº Positions</h2>
                    <div class="tabs">
                        <button class="tab active" data-tab="open" onclick="switchPositionTab('open')">Open</button>
                        <button class="tab" data-tab="closed" onclick="switchPositionTab('closed')">Closed</button>
                    </div>
                    <div class="signal-list" id="positionList">
                        <div class="loading">Loading positions...</div>
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div class="right-column">
                <!-- Performance Chart -->
                <div class="card">
                    <h2>üìà P&L Over Time</h2>
                    <div class="chart-container">
                        <canvas id="pnlChart"></canvas>
                    </div>
                </div>

                <!-- Strategy Performance -->
                <div class="card">
                    <h2>üéÆ Strategy Performance</h2>
                    <div class="strategy-grid" id="strategyGrid">
                        <div class="loading">Loading...</div>
                    </div>
                </div>

                <!-- Protocol Performance -->
                <div class="card">
                    <h2>üèõÔ∏è Top Protocols</h2>
                    <div class="strategy-grid" id="protocolGrid">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // DATA STORE (localStorage-based - works without backend)
        // ========================================
        const STORAGE_KEYS = {
            SIGNALS: 'nexxore_signals',
            POSITIONS: 'nexxore_positions',
            PORTFOLIO: 'nexxore_portfolio',
            PNL_HISTORY: 'nexxore_pnl_history'
        };

        // Portfolio management
        function getPortfolio() {
            const stored = localStorage.getItem(STORAGE_KEYS.PORTFOLIO);
            if (stored) return JSON.parse(stored);
            
            const initial = {
                totalCapital: 100000,
                availableCapital: 100000,
                allocatedCapital: 0,
                realizedPnl: 0,
                totalTrades: 0,
                winningTrades: 0,
                losingTrades: 0
            };
            savePortfolio(initial);
            return initial;
        }

        function savePortfolio(portfolio) {
            localStorage.setItem(STORAGE_KEYS.PORTFOLIO, JSON.stringify(portfolio));
        }

        function getSignals() {
            const stored = localStorage.getItem(STORAGE_KEYS.SIGNALS);
            return stored ? JSON.parse(stored) : [];
        }

        function saveSignals(signals) {
            localStorage.setItem(STORAGE_KEYS.SIGNALS, JSON.stringify(signals));
        }

        function getPositions() {
            const stored = localStorage.getItem(STORAGE_KEYS.POSITIONS);
            return stored ? JSON.parse(stored) : [];
        }

        function savePositions(positions) {
            localStorage.setItem(STORAGE_KEYS.POSITIONS, JSON.stringify(positions));
        }

        function getPnlHistory() {
            const stored = localStorage.getItem(STORAGE_KEYS.PNL_HISTORY);
            return stored ? JSON.parse(stored) : [];
        }

        function savePnlHistory(history) {
            localStorage.setItem(STORAGE_KEYS.PNL_HISTORY, JSON.stringify(history));
        }

        // ========================================
        // ML-POWERED DATA PIPELINE - Research Agent
        // ========================================
        
        // API endpoints
        const API_ENDPOINTS = {
            alphaScanner: '/api/alpha-scanner-v2',
            defillama: {
                protocols: 'https://api.llama.fi/protocols',
                yields: 'https://yields.llama.fi/pools',
                dexVolumes: 'https://api.llama.fi/overview/dexs',
                fees: 'https://api.llama.fi/overview/fees'
            },
            coingecko: {
                markets: 'https://api.coingecko.com/api/v3/coins/markets'
            },
            fearGreed: 'https://api.alternative.me/fng/?limit=30'
        };

        // Protocol to CoinGecko ID mapping (expanded)
        const PROTOCOL_MAPPINGS = {
            'lido': { coingecko: 'lido-dao', symbol: 'LDO', category: 'liquid-staking' },
            'aave': { coingecko: 'aave', symbol: 'AAVE', category: 'lending' },
            'uniswap': { coingecko: 'uniswap', symbol: 'UNI', category: 'dex' },
            'makerdao': { coingecko: 'maker', symbol: 'MKR', category: 'cdp' },
            'curve-dex': { coingecko: 'curve-dao-token', symbol: 'CRV', category: 'dex' },
            'compound-finance': { coingecko: 'compound-governance-token', symbol: 'COMP', category: 'lending' },
            'eigenlayer': { coingecko: 'eigenlayer', symbol: 'EIGEN', category: 'restaking' },
            'rocket-pool': { coingecko: 'rocket-pool', symbol: 'RPL', category: 'liquid-staking' },
            'gmx': { coingecko: 'gmx', symbol: 'GMX', category: 'perps' },
            'pendle': { coingecko: 'pendle', symbol: 'PENDLE', category: 'yield' },
            'ethena': { coingecko: 'ethena', symbol: 'ENA', category: 'synthetic' },
            'morpho': { coingecko: 'morpho', symbol: 'MORPHO', category: 'lending' },
            'jupiter': { coingecko: 'jupiter-exchange-solana', symbol: 'JUP', category: 'dex' },
            'raydium': { coingecko: 'raydium', symbol: 'RAY', category: 'dex' },
            'dydx': { coingecko: 'dydx-chain', symbol: 'DYDX', category: 'perps' },
            'pancakeswap': { coingecko: 'pancakeswap-token', symbol: 'CAKE', category: 'dex' },
            'sushiswap': { coingecko: 'sushi', symbol: 'SUSHI', category: 'dex' },
            'balancer-v2': { coingecko: 'balancer', symbol: 'BAL', category: 'dex' },
            'convex-finance': { coingecko: 'convex-finance', symbol: 'CVX', category: 'yield' },
            'yearn-finance': { coingecko: 'yearn-finance', symbol: 'YFI', category: 'yield' },
            'ondo-finance': { coingecko: 'ondo-finance', symbol: 'ONDO', category: 'rwa' },
            'jito': { coingecko: 'jito-governance-token', symbol: 'JTO', category: 'liquid-staking' },
            'aerodrome': { coingecko: 'aerodrome-finance', symbol: 'AERO', category: 'dex' },
            'velodrome': { coingecko: 'velodrome-finance', symbol: 'VELO', category: 'dex' },
            'hyperliquid': { coingecko: 'hyperliquid', symbol: 'HYPE', category: 'perps' }
        };

        // ML Feature weights for scoring
        const ML_FEATURE_WEIGHTS = {
            tvlMomentum: 0.12,
            tvlAcceleration: 0.08,
            priceStrength: 0.10,
            volumeMomentum: 0.08,
            yieldAttractiveness: 0.10,
            yieldSustainability: 0.06,
            revenueGrowth: 0.10,
            feeEfficiency: 0.06,
            trendStrength: 0.06,
            sentimentScore: 0.08,
            categoryMomentum: 0.06,
            riskScore: 0.05,
            liquidityScore: 0.05
        };

        // Hot categories (narrative multipliers)
        const CATEGORY_MOMENTUM = {
            'restaking': 1.25,
            'liquid-staking': 1.15,
            'rwa': 1.20,
            'perps': 1.10,
            'lending': 1.05,
            'yield': 1.08,
            'dex': 1.0,
            'synthetic': 1.05
        };

        let dataCache = {
            protocols: null,
            yields: null,
            prices: null,
            dexVolumes: null,
            fees: null,
            fearGreed: null,
            lastUpdate: null
        };

        async function fetchLiveSignals() {
            showStatus('üîç Running ML-Powered Alpha Scanner...', 'info');
            document.getElementById('signalList').innerHTML = '<div class="loading">Analyzing 30+ DeFi protocols with ML features...</div>';
            updateDataFreshness('fetching');

            try {
                // Try the ML-powered API first
                const apiResponse = await fetch(API_ENDPOINTS.alphaScanner);
                
                if (apiResponse.ok) {
                    const data = await apiResponse.json();
                    
                    if (data.success && data.signals?.length > 0) {
                        // API returned ML-analyzed signals
                        const newSignals = data.signals.map(s => convertApiSignalToLocal(s));
                        
                        // Update cache metadata
                        dataCache.lastUpdate = Date.now();
                        
                        // Merge with existing signals
                        const existingSignals = getSignals();
                        const existingIds = new Set(existingSignals.map(s => s.id));
                        const uniqueNew = newSignals.filter(s => !existingIds.has(s.id));
                        
                        const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                        const validExisting = existingSignals.filter(s => 
                            new Date(s.generatedAt).getTime() > cutoff && s.status !== 'EXPIRED'
                        );
                        
                        const allSignals = [...uniqueNew, ...validExisting].slice(0, 100);
                        saveSignals(allSignals);

                        updateDataFreshness('live');
                        showStatus(`‚úÖ ML Scanner found ${uniqueNew.length} alpha opportunities!`, 'success');
                        showToast(`ü§ñ ML Analysis: ${data.summary.strongBuy + data.summary.buy} BUY signals | F&G: ${data.market?.fearGreed}`);
                        
                        // Update market sentiment display
                        updateMarketSentiment(data.market);
                        
                        refreshData();
                        return;
                    }
                }
                
                // Fallback to direct API fetching if ML API fails
                await fetchDirectFromAPIs();
                
            } catch (error) {
                console.error('ML API error:', error);
                showStatus('‚ö†Ô∏è ML API unavailable - fetching directly from data sources...', 'info');
                await fetchDirectFromAPIs();
            }
        }

        function convertApiSignalToLocal(apiSignal) {
            const currentPrice = apiSignal.price?.current || 1;
            const volatility = Math.abs(apiSignal.price?.change24h || 5) / 100;
            const targetMultiplier = 1 + (apiSignal.signal.alphaScore / 400) + volatility;
            const stopMultiplier = 1 - (0.04 + volatility * 0.3);

            return {
                id: `sig_${apiSignal.protocol.id}_${Date.now()}`,
                protocol: apiSignal.protocol.name,
                slug: apiSignal.protocol.id,
                chain: apiSignal.protocol.chains?.[0] || 'ethereum',
                chains: apiSignal.protocol.chains || [],
                type: apiSignal.protocol.category,
                category: apiSignal.protocol.category,
                token: apiSignal.protocol.symbol,
                
                action: apiSignal.signal.action.includes('BUY') ? 'BUY' : 
                        apiSignal.signal.action.includes('SELL') ? 'SELL' : 'WATCH',
                alphaScore: apiSignal.signal.alphaScore,
                confidence: apiSignal.signal.confidence,
                confidenceLevel: apiSignal.signal.confidenceLevel,
                riskLevel: apiSignal.signal.alphaScore >= 75 ? 'LOW' : 
                           apiSignal.signal.alphaScore >= 60 ? 'MEDIUM' : 'HIGH',
                
                entryPrice: currentPrice,
                targetPrice: currentPrice * targetMultiplier,
                stopLoss: currentPrice * stopMultiplier,
                expectedReturn: ((targetMultiplier - 1) * 100).toFixed(1),
                
                tvl: apiSignal.protocol.tvl,
                tvlChange24h: apiSignal.metrics?.tvlChange1d || 0,
                tvlChange7d: apiSignal.metrics?.tvlChange7d || 0,
                apy: apiSignal.metrics?.maxApy || 0,
                priceChange24h: apiSignal.price?.change24h || 0,
                marketCap: apiSignal.price?.marketCap || 0,
                volume24h: apiSignal.metrics?.volume24h || 0,
                fees24h: apiSignal.metrics?.fees24h || 0,
                
                // ML Feature scores
                mlFeatures: apiSignal.features || {},
                
                reasoning: apiSignal.reasoning?.join('. ') || 'ML-generated signal based on multi-factor analysis.',
                factors: apiSignal.reasoning || [],
                
                status: 'ACTIVE',
                source: 'ML_SCANNER',
                dataFreshness: 'LIVE',
                rank: apiSignal.rank,
                generatedAt: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
            };
        }

        function updateMarketSentiment(marketData) {
            if (!marketData) return;
            
            let sentimentEl = document.getElementById('marketSentiment');
            if (!sentimentEl) {
                sentimentEl = document.createElement('div');
                sentimentEl.id = 'marketSentiment';
                sentimentEl.style.cssText = 'position:fixed;top:110px;right:20px;padding:8px 14px;border-radius:8px;font-size:0.8rem;z-index:100;background:rgba(0,0,0,0.8);border:1px solid rgba(255,255,255,0.1);';
                document.body.appendChild(sentimentEl);
            }
            
            const fg = marketData.fearGreed || 50;
            const sentiment = marketData.sentiment || 'Neutral';
            const trend = marketData.trend || 0;
            const trendIcon = trend > 0 ? 'üìà' : trend < 0 ? 'üìâ' : '‚û°Ô∏è';
            
            let color = '#ffaa00';
            if (fg >= 75) color = '#00ff88';
            else if (fg >= 55) color = '#88ff00';
            else if (fg <= 25) color = '#ff4444';
            else if (fg <= 45) color = '#ff8800';
            
            sentimentEl.innerHTML = `
                <div style="color:${color};font-weight:600;">F&G: ${fg} - ${sentiment}</div>
                <div style="color:#888;font-size:0.7rem;">${trendIcon} ${trend >= 0 ? '+' : ''}${trend} vs last week</div>
            `;
        }

        async function fetchDirectFromAPIs() {
            showStatus('üîç Fetching live data from multiple sources...', 'info');
            document.getElementById('signalList').innerHTML = '<div class="loading">Aggregating DeFiLlama, CoinGecko, Alternative.me...</div>';

            try {
                // Fetch all data sources in parallel
                const [protocolsRes, yieldsRes, dexVolRes, feesRes, fgRes] = await Promise.all([
                    fetch(API_ENDPOINTS.defillama.protocols),
                    fetch(API_ENDPOINTS.defillama.yields),
                    fetch(API_ENDPOINTS.defillama.dexVolumes).catch(() => null),
                    fetch(API_ENDPOINTS.defillama.fees).catch(() => null),
                    fetch(API_ENDPOINTS.fearGreed).catch(() => null)
                ]);

                if (!protocolsRes.ok || !yieldsRes.ok) {
                    throw new Error('Core API request failed');
                }

                const [allProtocols, yieldsData] = await Promise.all([
                    protocolsRes.json(),
                    yieldsRes.json()
                ]);

                // Process protocols
                const protocols = allProtocols
                    .filter(p => p.tvl > 50_000_000)
                    .map(p => ({
                        id: p.slug,
                        name: p.name,
                        symbol: p.symbol,
                        tvl: p.tvl,
                        tvlChange1d: p.change_1d || 0,
                        tvlChange7d: p.change_7d || 0,
                        tvlChange1m: p.change_1m || 0,
                        chains: p.chains || [],
                        category: p.category,
                        audits: p.audits,
                        listedAt: p.listedAt
                    }))
                    .sort((a, b) => b.tvl - a.tvl);

                const yields = (yieldsData?.data || [])
                    .filter(y => y.tvlUsd > 1_000_000 && y.apy > 0 && y.apy < 1000);

                // Parse optional data
                let dexVolumes = [];
                let fees = [];
                let fearGreed = { current: 50, classification: 'Neutral', trend: 0 };

                if (dexVolRes?.ok) {
                    const dv = await dexVolRes.json();
                    dexVolumes = (dv?.protocols || []).map(d => ({
                        name: d.name,
                        volume24h: d.total24h || 0
                    }));
                }

                if (feesRes?.ok) {
                    const f = await feesRes.json();
                    fees = (f?.protocols || []).map(f => ({
                        name: f.name,
                        fees24h: f.total24h || 0,
                        feesChange: f.change_1d || 0
                    }));
                }

                if (fgRes?.ok) {
                    const fg = await fgRes.json();
                    fearGreed = {
                        current: parseInt(fg?.data?.[0]?.value) || 50,
                        classification: fg?.data?.[0]?.value_classification || 'Neutral',
                        trend: fg?.data ? parseInt(fg.data[0]?.value) - parseInt(fg.data[7]?.value) : 0
                    };
                }

                // Fetch CoinGecko market data
                const cgIds = Object.values(PROTOCOL_MAPPINGS).map(m => m.coingecko).join(',');
                const marketRes = await fetch(
                    `${API_ENDPOINTS.coingecko.markets}?vs_currency=usd&ids=${cgIds}&order=market_cap_desc&sparkline=true&price_change_percentage=1h,24h,7d,30d`
                );
                
                let marketData = [];
                if (marketRes.ok) {
                    const md = await marketRes.json();
                    marketData = (md || []).map(c => ({
                        id: c.id,
                        symbol: c.symbol?.toUpperCase(),
                        price: c.current_price,
                        marketCap: c.market_cap,
                        volume24h: c.total_volume,
                        priceChange1h: c.price_change_percentage_1h_in_currency || 0,
                        priceChange24h: c.price_change_percentage_24h || 0,
                        priceChange7d: c.price_change_percentage_7d_in_currency || 0,
                        priceChange30d: c.price_change_percentage_30d_in_currency || 0,
                        sparkline: c.sparkline_in_7d?.price || []
                    }));
                }

                // Update cache
                dataCache = {
                    protocols,
                    yields,
                    marketData,
                    dexVolumes,
                    fees,
                    fearGreed,
                    lastUpdate: Date.now()
                };

                // Generate ML-scored signals
                const newSignals = [];
                const existingSignals = getSignals();
                const existingIds = new Set(existingSignals.map(s => s.id));

                for (const [slug, mapping] of Object.entries(PROTOCOL_MAPPINGS)) {
                    const signal = generateMLSignal(slug, mapping, dataCache);
                    if (signal && signal.alphaScore >= 45 && !existingIds.has(signal.id)) {
                        newSignals.push(signal);
                    }
                }

                // Sort by alpha score
                newSignals.sort((a, b) => b.alphaScore - a.alphaScore);
                const topSignals = newSignals.slice(0, 25);

                // Merge with existing
                const cutoff = Date.now() - 24 * 60 * 60 * 1000;
                const validExisting = existingSignals.filter(s => 
                    new Date(s.generatedAt).getTime() > cutoff && s.status !== 'EXPIRED'
                );
                
                const allSignals = [...topSignals, ...validExisting].slice(0, 100);
                saveSignals(allSignals);

                updateDataFreshness('live');
                updateMarketSentiment(fearGreed);
                showStatus(`‚úÖ ML Analysis complete: ${topSignals.length} alpha signals!`, 'success');
                showToast(`üìä ${topSignals.length} signals from ${protocols.length} protocols | F&G: ${fearGreed.current}`);
                
                refreshData();

            } catch (error) {
                console.error('Direct API fetch failed:', error);
                showStatus('‚ö†Ô∏è API error - using cached/fallback data', 'error');
                updateDataFreshness('error');
                await fetchFallbackSignals();
            }
        }

        // ML Feature Engineering for signal generation
        function generateMLSignal(slug, mapping, data) {
            const { protocols, yields, marketData, dexVolumes, fees, fearGreed } = data;
            
            const protocol = protocols.find(p => p.id === slug);
            if (!protocol) return null;

            const market = marketData.find(m => m.id === mapping.coingecko);
            const protocolYields = yields.filter(y => 
                y.project?.toLowerCase() === slug.toLowerCase()
            );
            const protocolVolume = dexVolumes.find(d => 
                d.name?.toLowerCase().includes(slug.split('-')[0])
            );
            const protocolFees = fees.find(f => 
                f.name?.toLowerCase().includes(slug.split('-')[0])
            );

            // Calculate ML features
            const features = {};
            
            // TVL Features
            const tvlChange1d = protocol.tvlChange1d || 0;
            const tvlChange7d = protocol.tvlChange7d || 0;
            features.tvlMomentum = normalize((tvlChange1d * 0.5) + (tvlChange7d * 0.3), -20, 50);
            features.tvlAcceleration = normalize(tvlChange1d - (tvlChange7d / 7), -5, 10);
            
            // Price Features
            if (market) {
                const priceScore = (market.priceChange1h || 0) * 0.1 +
                                   (market.priceChange24h || 0) * 0.3 +
                                   (market.priceChange7d || 0) * 0.3 +
                                   (market.priceChange30d || 0) * 0.3;
                features.priceStrength = normalize(priceScore, -30, 50);
                features.volumeMomentum = market.marketCap > 0 
                    ? normalize((market.volume24h / market.marketCap) * 100, 0, 20)
                    : 0.5;
                features.liquidityScore = normalize(Math.log10(Math.max(market.volume24h || 1, 1)), 5, 9);
                
                // Trend analysis from sparkline
                if (market.sparkline?.length > 10) {
                    features.trendStrength = calculateTrendStrength(market.sparkline);
                } else {
                    features.trendStrength = 0.5;
                }
            } else {
                features.priceStrength = 0.5;
                features.volumeMomentum = 0.5;
                features.liquidityScore = 0.5;
                features.trendStrength = 0.5;
            }
            
            // Yield Features
            const maxApy = protocolYields.length > 0 
                ? Math.max(...protocolYields.map(y => y.apy))
                : 0;
            const avgApy = protocolYields.length > 0
                ? protocolYields.reduce((s, y) => s + y.apy, 0) / protocolYields.length
                : 0;
            features.yieldAttractiveness = normalize(avgApy - 5, 0, 50); // vs 5% risk-free
            features.yieldSustainability = protocolYields.length > 0 ? 0.6 : 0.5; // Conservative estimate
            
            // Revenue Features
            const feesChange = protocolFees?.feesChange || 0;
            features.revenueGrowth = normalize(feesChange, -30, 50);
            const feeToTvl = protocol.tvl > 0 && protocolFees?.fees24h 
                ? (protocolFees.fees24h * 365 / protocol.tvl) * 100 
                : 0;
            features.feeEfficiency = normalize(feeToTvl, 0, 30);
            
            // Sentiment Features
            const fg = fearGreed?.current || 50;
            features.sentimentScore = normalize(fg, 0, 100);
            features.categoryMomentum = CATEGORY_MOMENTUM[mapping.category] || 1.0;
            
            // Risk Features
            const hasAudit = protocol.audits && protocol.audits > 0;
            const ageMonths = protocol.listedAt 
                ? (Date.now() / 1000 - protocol.listedAt) / (30 * 24 * 3600)
                : 12;
            features.riskScore = (hasAudit ? 0.35 : 0) + 
                                 (Math.min(ageMonths / 24, 1) * 0.35) +
                                 (Math.min((protocol.chains?.length || 1) / 5, 1) * 0.3);

            // Calculate weighted alpha score
            let alphaScore = 0;
            let totalWeight = 0;
            
            for (const [feature, weight] of Object.entries(ML_FEATURE_WEIGHTS)) {
                const value = features[feature];
                if (typeof value === 'number' && !isNaN(value)) {
                    if (feature === 'categoryMomentum') {
                        alphaScore += normalize(value, 0.9, 1.3) * weight;
                    } else {
                        alphaScore += value * weight;
                    }
                    totalWeight += weight;
                }
            }
            
            alphaScore = totalWeight > 0 ? (alphaScore / totalWeight) * 100 : 50;
            alphaScore = Math.max(0, Math.min(100, Math.round(alphaScore)));

            // Generate reasoning
            const reasoning = [];
            if (features.tvlMomentum > 0.7) reasoning.push(`üöÄ Strong TVL momentum (+${tvlChange1d.toFixed(1)}% 24h)`);
            if (features.priceStrength > 0.7) reasoning.push(`üìà Strong price action`);
            if (features.yieldAttractiveness > 0.7) reasoning.push(`üí∞ Attractive yields (${avgApy.toFixed(1)}% APY)`);
            if (features.categoryMomentum > 1.1) reasoning.push(`üî• Hot sector: ${mapping.category}`);
            if (features.revenueGrowth > 0.7) reasoning.push(`üìä Revenue growing`);
            if (features.riskScore < 0.4) reasoning.push(`‚ö†Ô∏è Elevated risk factors`);
            
            if (reasoning.length === 0) {
                reasoning.push('Mixed signals - ML analysis suggests caution');
            }

            // Determine signal action
            let action = 'WATCH';
            if (alphaScore >= 75) action = 'STRONG BUY';
            else if (alphaScore >= 60) action = 'BUY';
            else if (alphaScore >= 40) action = 'HOLD';
            else if (alphaScore >= 25) action = 'SELL';

            // Calculate targets
            const currentPrice = market?.price || 1;
            const volatility = Math.abs(market?.priceChange24h || 5) / 100;
            const targetMultiplier = 1 + (alphaScore / 400) + volatility;
            const stopMultiplier = 1 - (0.04 + volatility * 0.3);

            // Calculate confidence
            const dataPoints = [protocol?.tvl > 0, market?.price > 0, protocolYields.length > 0, 
                               protocolVolume?.volume24h > 0, protocolFees?.fees24h > 0];
            const confidence = Math.min(95, 50 + (dataPoints.filter(Boolean).length * 10));

            return {
                id: `sig_${slug}_${Date.now()}`,
                protocol: protocol.name,
                slug: slug,
                chain: protocol.chains?.[0] || 'ethereum',
                chains: protocol.chains || [],
                type: mapping.category,
                category: mapping.category,
                token: mapping.symbol,
                
                action: action,
                alphaScore: alphaScore,
                confidence: confidence,
                confidenceLevel: confidence >= 75 ? 'HIGH' : confidence >= 50 ? 'MEDIUM' : 'LOW',
                riskLevel: alphaScore >= 75 ? 'LOW' : alphaScore >= 60 ? 'MEDIUM' : 'HIGH',
                
                entryPrice: currentPrice,
                targetPrice: currentPrice * targetMultiplier,
                stopLoss: currentPrice * stopMultiplier,
                expectedReturn: ((targetMultiplier - 1) * 100).toFixed(1),
                
                tvl: protocol.tvl,
                tvlChange24h: tvlChange1d,
                tvlChange7d: tvlChange7d,
                apy: maxApy,
                priceChange24h: market?.priceChange24h || 0,
                marketCap: market?.marketCap || 0,
                volume24h: market?.volume24h || 0,
                fees24h: protocolFees?.fees24h || 0,
                
                mlFeatures: {
                    tvlMomentum: Math.round(features.tvlMomentum * 100),
                    priceStrength: Math.round(features.priceStrength * 100),
                    yieldScore: Math.round(features.yieldAttractiveness * 100),
                    revenueScore: Math.round(features.revenueGrowth * 100),
                    riskScore: Math.round(features.riskScore * 100),
                    sentiment: Math.round(features.sentimentScore * 100)
                },
                
                reasoning: reasoning.slice(0, 4).join('. ') + '.',
                factors: reasoning,
                
                status: 'ACTIVE',
                source: 'ML_DIRECT',
                dataFreshness: 'LIVE',
                generatedAt: new Date().toISOString(),
                expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
            };
        }

        // Helper functions
        function normalize(value, min, max) {
            if (max === min) return 0.5;
            return Math.max(0, Math.min(1, (value - min) / (max - min)));
        }

        function calculateTrendStrength(sparkline) {
            if (!sparkline || sparkline.length < 7) return 0.5;
            
            const n = sparkline.length;
            const x = Array.from({length: n}, (_, i) => i);
            const sumX = x.reduce((s, v) => s + v, 0);
            const sumY = sparkline.reduce((s, v) => s + v, 0);
            const sumXY = x.reduce((s, v, i) => s + v * sparkline[i], 0);
            const sumX2 = x.reduce((s, v) => s + v * v, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const avgPrice = sumY / n;
            const normalizedSlope = avgPrice !== 0 ? (slope / avgPrice) * 100 : 0;
            
            return normalize(normalizedSlope, -5, 5);
        }

        // Fallback with simulated fresh data (when APIs fail)
        async function fetchFallbackSignals() {
            const FALLBACK_PROTOCOLS = [
                { name: 'Lido', slug: 'lido', chain: 'ethereum', category: 'Liquid Staking', tvl: 28e9, change_1d: 2.1, change_7d: 5.3 },
                { name: 'AAVE', slug: 'aave', chain: 'ethereum', category: 'Lending', tvl: 12.5e9, change_1d: 1.5, change_7d: 3.2 },
                { name: 'Eigenlayer', slug: 'eigenlayer', chain: 'ethereum', category: 'Restaking', tvl: 15e9, change_1d: 4.2, change_7d: 8.1 },
                { name: 'Maker', slug: 'makerdao', chain: 'ethereum', category: 'CDP', tvl: 8.1e9, change_1d: 0.8, change_7d: 2.1 },
                { name: 'Uniswap', slug: 'uniswap', chain: 'ethereum', category: 'DEX', tvl: 5.8e9, change_1d: -0.5, change_7d: 1.2 },
                { name: 'Ethena', slug: 'ethena', chain: 'ethereum', category: 'Stablecoin', tvl: 5.5e9, change_1d: 3.5, change_7d: 12.3 },
                { name: 'Pendle', slug: 'pendle', chain: 'ethereum', category: 'Yield', tvl: 4.2e9, change_1d: 5.8, change_7d: 15.2 },
                { name: 'Rocket Pool', slug: 'rocket-pool', chain: 'ethereum', category: 'Liquid Staking', tvl: 3.8e9, change_1d: 1.2, change_7d: 2.8 },
                { name: 'Morpho', slug: 'morpho', chain: 'ethereum', category: 'Lending', tvl: 3.2e9, change_1d: 2.8, change_7d: 6.5 },
                { name: 'Compound', slug: 'compound', chain: 'ethereum', category: 'Lending', tvl: 2.8e9, change_1d: 0.3, change_7d: 1.1 },
                { name: 'GMX', slug: 'gmx', chain: 'arbitrum', category: 'Perps', tvl: 520e6, change_1d: 4.1, change_7d: 9.3 },
                { name: 'Jupiter', slug: 'jupiter', chain: 'solana', category: 'DEX', tvl: 1.2e9, change_1d: 6.2, change_7d: 18.5 },
                { name: 'Raydium', slug: 'raydium', chain: 'solana', category: 'DEX', tvl: 680e6, change_1d: 3.8, change_7d: 11.2 },
                { name: 'dYdX', slug: 'dydx', chain: 'dydx', category: 'Perps', tvl: 480e6, change_1d: 2.5, change_7d: 5.8 }
            ];

            const FALLBACK_YIELDS = {
                'lido': 3.8, 'aave': 4.5, 'eigenlayer': 6.2, 'makerdao': 8.0,
                'uniswap': 12.5, 'ethena': 27.0, 'pendle': 25.0, 'rocket-pool': 3.5,
                'morpho': 5.8, 'compound': 4.2, 'gmx': 18.5, 'jupiter': 15.0,
                'raydium': 22.0, 'dydx': 20.0
            };

            const FALLBACK_PRICES = {
                'lido': { usd: 1.85, usd_24h_change: 2.3 },
                'aave': { usd: 245.50, usd_24h_change: 4.1 },
                'eigenlayer': { usd: 3.20, usd_24h_change: 6.8 },
                'makerdao': { usd: 1450, usd_24h_change: 1.2 },
                'uniswap': { usd: 11.25, usd_24h_change: -0.8 },
                'ethena': { usd: 0.85, usd_24h_change: 8.5 },
                'pendle': { usd: 4.85, usd_24h_change: 12.3 },
                'rocket-pool': { usd: 18.50, usd_24h_change: 1.5 },
                'morpho': { usd: 2.15, usd_24h_change: 5.2 },
                'compound': { usd: 52.30, usd_24h_change: 0.5 },
                'gmx': { usd: 28.75, usd_24h_change: 7.8 },
                'jupiter': { usd: 0.92, usd_24h_change: 15.2 },
                'raydium': { usd: 1.75, usd_24h_change: 9.3 },
                'dydx': { usd: 1.45, usd_24h_change: 3.2 }
            };

            // Generate fallback yields array
            const yields = Object.entries(FALLBACK_YIELDS).map(([project, apy]) => ({
                project, apy
            }));

            // Create fallback data cache
            const fallbackData = {
                protocols: FALLBACK_PROTOCOLS.map(p => ({
                    id: p.slug,
                    name: p.name,
                    tvl: p.tvl,
                    tvlChange1d: p.change_1d,
                    tvlChange7d: p.change_7d,
                    chains: [p.chain],
                    category: p.category,
                    audits: 1,
                    listedAt: Date.now()/1000 - 365*24*3600 // 1 year ago
                })),
                yields: Object.entries(FALLBACK_YIELDS).map(([project, apy]) => ({
                    project, apy, tvlUsd: 100e6
                })),
                marketData: Object.entries(FALLBACK_PRICES).map(([id, data]) => ({
                    id: PROTOCOL_MAPPINGS[id]?.coingecko || id,
                    price: data.usd,
                    priceChange24h: data.usd_24h_change,
                    volume24h: 1e6,
                    marketCap: 1e9
                })),
                dexVolumes: [],
                fees: [],
                fearGreed: { current: 50, classification: 'Neutral', trend: 0 }
            };

            const newSignals = [];
            for (const [slug, mapping] of Object.entries(PROTOCOL_MAPPINGS)) {
                const signal = generateMLSignal(slug, mapping, fallbackData);
                if (signal && signal.alphaScore >= 45) {
                    signal.source = 'FALLBACK';
                    signal.dataFreshness = 'CACHED';
                    newSignals.push(signal);
                }
            }

            newSignals.sort((a, b) => b.alphaScore - a.alphaScore);
            
            const existingSignals = getSignals();
            const allSignals = [...newSignals, ...existingSignals].slice(0, 100);
            saveSignals(allSignals);

            updateDataFreshness('cached');
            refreshData();
        }

        function updateDataFreshness(status) {
            let indicator = document.getElementById('dataFreshness');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'dataFreshness';
                indicator.style.cssText = 'position:fixed;top:70px;right:20px;padding:6px 12px;border-radius:20px;font-size:0.75rem;font-weight:600;z-index:100;';
                document.body.appendChild(indicator);
            }

            const statuses = {
                'live': { bg: 'rgba(0,255,136,0.2)', color: '#00ff88', text: 'üü¢ LIVE DATA' },
                'cached': { bg: 'rgba(255,170,0,0.2)', color: '#ffaa00', text: 'üü° CACHED' },
                'fetching': { bg: 'rgba(0,212,255,0.2)', color: '#00d4ff', text: 'üîÑ FETCHING...' },
                'error': { bg: 'rgba(255,68,68,0.2)', color: '#ff4444', text: 'üî¥ API ERROR' }
            };

            const s = statuses[status] || statuses['cached'];
            indicator.style.background = s.bg;
            indicator.style.color = s.color;
            indicator.style.border = `1px solid ${s.color}`;
            indicator.textContent = s.text;

            if (dataCache.lastUpdate) {
                const age = Math.round((Date.now() - dataCache.lastUpdate) / 1000 / 60);
                if (age > 0) {
                    indicator.textContent += ` (${age}m ago)`;
                }
            }
        }

        // ========================================
        // MOCK TRADING ENGINE
        // ========================================

        function executeSignal(signalId) {
            const signals = getSignals();
            const signal = signals.find(s => s.id === signalId);
            if (!signal) {
                showToast('‚ùå Signal not found');
                return;
            }

            const portfolio = getPortfolio();
            
            // Calculate position size (5-10% of available capital based on score)
            const sizePct = 0.05 + (signal.alphaScore / 1000);
            const positionSize = Math.min(
                portfolio.availableCapital * sizePct,
                10000,
                portfolio.availableCapital * 0.9
            );

            if (positionSize < 100) {
                showToast('‚ùå Insufficient capital for trade');
                return;
            }

            // Create position
            const position = {
                id: `pos_${Date.now()}`,
                signalId: signal.id,
                protocol: signal.protocol,
                chain: signal.chain,
                type: signal.type || signal.category,
                token: signal.token,
                positionType: 'LONG',
                entryPrice: signal.entryPrice,
                currentPrice: signal.entryPrice,
                entryAmount: positionSize,
                quantity: positionSize / signal.entryPrice,
                stopLoss: signal.stopLoss,
                takeProfit: signal.targetPrice,
                unrealizedPnl: 0,
                unrealizedPnlPct: 0,
                status: 'OPEN',
                entryTime: new Date().toISOString()
            };

            // Update portfolio
            portfolio.availableCapital -= positionSize;
            portfolio.allocatedCapital += positionSize;
            portfolio.totalTrades++;
            savePortfolio(portfolio);

            // Save position
            const positions = getPositions();
            positions.unshift(position);
            savePositions(positions);

            // Update signal status
            signal.status = 'EXECUTED';
            saveSignals(signals);

            showToast(`‚úÖ Opened ${signal.protocol} LONG: $${positionSize.toFixed(0)}`);
            refreshData();

            // Start price simulation
            simulatePriceMovement(position.id);
        }

        function closePosition(positionId) {
            const positions = getPositions();
            const position = positions.find(p => p.id === positionId);
            if (!position || position.status !== 'OPEN') return;

            const portfolio = getPortfolio();
            
            const realizedPnl = position.unrealizedPnl;
            const realizedPnlPct = position.unrealizedPnlPct;

            // Update position
            position.status = 'CLOSED';
            position.exitPrice = position.currentPrice;
            position.exitTime = new Date().toISOString();
            position.realizedPnl = realizedPnl;
            position.realizedPnlPct = realizedPnlPct;
            position.exitReason = 'MANUAL';

            // Update portfolio
            const returnedCapital = position.entryAmount + realizedPnl;
            portfolio.availableCapital += returnedCapital;
            portfolio.allocatedCapital -= position.entryAmount;
            portfolio.realizedPnl += realizedPnl;
            
            if (realizedPnl > 0) {
                portfolio.winningTrades++;
            } else {
                portfolio.losingTrades++;
            }

            savePortfolio(portfolio);
            savePositions(positions);

            // Record P&L history
            const history = getPnlHistory();
            history.push({
                date: new Date().toISOString(),
                pnl: realizedPnl,
                cumulative: portfolio.realizedPnl,
                protocol: position.protocol
            });
            savePnlHistory(history);

            const emoji = realizedPnl >= 0 ? 'üü¢' : 'üî¥';
            showToast(`${emoji} Closed ${position.protocol}: ${realizedPnl >= 0 ? '+' : ''}$${realizedPnl.toFixed(2)}`);
            refreshData();
        }

        // Price simulation intervals stored by position ID
        const priceSimulations = {};

        function simulatePriceMovement(positionId) {
            // Clear any existing simulation
            if (priceSimulations[positionId]) {
                clearInterval(priceSimulations[positionId]);
            }

            const interval = setInterval(() => {
                const positions = getPositions();
                const position = positions.find(p => p.id === positionId);
                
                if (!position || position.status !== 'OPEN') {
                    clearInterval(interval);
                    delete priceSimulations[positionId];
                    return;
                }

                // Realistic price movement
                const volatility = 0.004;
                const drift = 0.0003;
                const change = (Math.random() - 0.47) * volatility + drift;
                
                position.currentPrice = position.currentPrice * (1 + change);
                position.unrealizedPnl = (position.currentPrice - position.entryPrice) * position.quantity;
                position.unrealizedPnlPct = ((position.currentPrice - position.entryPrice) / position.entryPrice) * 100;

                // Check stop loss
                if (position.currentPrice <= position.stopLoss) {
                    clearInterval(interval);
                    delete priceSimulations[positionId];
                    position.exitReason = 'STOP_LOSS';
                    closePositionAuto(position);
                    showToast(`üõë Stop loss hit on ${position.protocol}`);
                    return;
                }

                // Check take profit
                if (position.currentPrice >= position.takeProfit) {
                    clearInterval(interval);
                    delete priceSimulations[positionId];
                    position.exitReason = 'TAKE_PROFIT';
                    closePositionAuto(position);
                    showToast(`üéØ Take profit hit on ${position.protocol}! üéâ`);
                    return;
                }

                savePositions(positions);
                updatePositionsUI();
                updateStatsUI();
            }, 2500);

            priceSimulations[positionId] = interval;
        }

        function closePositionAuto(position) {
            const positions = getPositions();
            const portfolio = getPortfolio();
            
            const realizedPnl = position.unrealizedPnl;

            position.status = 'CLOSED';
            position.exitPrice = position.currentPrice;
            position.exitTime = new Date().toISOString();
            position.realizedPnl = realizedPnl;
            position.realizedPnlPct = position.unrealizedPnlPct;

            const returnedCapital = position.entryAmount + realizedPnl;
            portfolio.availableCapital += returnedCapital;
            portfolio.allocatedCapital -= position.entryAmount;
            portfolio.realizedPnl += realizedPnl;
            
            if (realizedPnl > 0) {
                portfolio.winningTrades++;
            } else {
                portfolio.losingTrades++;
            }

            savePortfolio(portfolio);
            savePositions(positions);

            const history = getPnlHistory();
            history.push({
                date: new Date().toISOString(),
                pnl: realizedPnl,
                cumulative: portfolio.realizedPnl,
                protocol: position.protocol
            });
            savePnlHistory(history);

            refreshData();
        }

        function autoExecuteSignals() {
            const signals = getSignals().filter(s => s.status === 'ACTIVE' && s.alphaScore >= 65);
            
            if (signals.length === 0) {
                showToast('‚ö†Ô∏è No high-confidence signals to execute');
                return;
            }

            let executed = 0;
            for (const signal of signals.slice(0, 5)) {
                const portfolio = getPortfolio();
                if (portfolio.availableCapital > 5000) {
                    executeSignal(signal.id);
                    executed++;
                }
            }

            showToast(`‚ö° Auto-executed ${executed} positions`);
        }

        // ========================================
        // UI MANAGEMENT
        // ========================================

        let pnlChart;
        let currentSignalTab = 'active';
        let currentPositionTab = 'open';

        function refreshData() {
            updateStatsUI();
            updateSignalsUI();
            updatePositionsUI();
            updateStrategyUI();
            updateChartUI();
        }

        function updateStatsUI() {
            const portfolio = getPortfolio();
            const positions = getPositions().filter(p => p.status === 'OPEN');
            const signals = getSignals();

            const unrealizedPnl = positions.reduce((sum, p) => sum + (p.unrealizedPnl || 0), 0);
            const totalPnl = portfolio.realizedPnl + unrealizedPnl;
            const totalValue = portfolio.availableCapital + portfolio.allocatedCapital + unrealizedPnl;
            const pnlPct = (totalPnl / portfolio.totalCapital) * 100;

            const completedTrades = portfolio.winningTrades + portfolio.losingTrades;
            const winRate = completedTrades > 0 ? (portfolio.winningTrades / completedTrades) * 100 : 0;

            document.getElementById('portfolioValue').textContent = `$${totalValue.toLocaleString(undefined, {maximumFractionDigits: 0})}`;
            document.getElementById('portfolioPnl').textContent = `Started: $${portfolio.totalCapital.toLocaleString()}`;
            
            const totalPnlEl = document.getElementById('totalPnl');
            totalPnlEl.textContent = `${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)}`;
            totalPnlEl.className = `value ${totalPnl >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('totalPnlPct').textContent = `${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%`;

            document.getElementById('winRate').textContent = `${winRate.toFixed(0)}%`;
            document.getElementById('winLossCount').textContent = `${portfolio.winningTrades}W / ${portfolio.losingTrades}L`;

            const activeSignals = signals.filter(s => s.status === 'ACTIVE').length;
            document.getElementById('activeSignals').textContent = activeSignals;
            document.getElementById('totalSignals').textContent = `${signals.length} total`;

            document.getElementById('openPositions').textContent = positions.length;
            document.getElementById('unrealizedPnl').textContent = `${unrealizedPnl >= 0 ? '+' : ''}$${unrealizedPnl.toFixed(2)} unrealized`;

            const closedPositions = getPositions().filter(p => p.status === 'CLOSED');
            const grossWin = closedPositions.filter(p => p.realizedPnl > 0).reduce((s, p) => s + p.realizedPnl, 0);
            const grossLoss = Math.abs(closedPositions.filter(p => p.realizedPnl < 0).reduce((s, p) => s + p.realizedPnl, 0));
            const profitFactor = grossLoss > 0 ? grossWin / grossLoss : grossWin > 0 ? '‚àû' : '0.00';
            document.getElementById('profitFactor').textContent = typeof profitFactor === 'number' ? profitFactor.toFixed(2) : profitFactor;
        }

        function updateSignalsUI() {
            const container = document.getElementById('signalList');
            let signals = getSignals();

            if (currentSignalTab === 'active') {
                signals = signals.filter(s => s.status === 'ACTIVE');
            } else if (currentSignalTab === 'executed') {
                signals = signals.filter(s => s.status === 'EXECUTED');
            }

            if (signals.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:48px;height:48px;margin-bottom:1rem;opacity:0.5">
                            <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                        </svg>
                        <p>${currentSignalTab === 'active' ? 'Click "Fetch Signals" to scan for opportunities' : 'No ' + currentSignalTab + ' signals'}</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = signals.map(signal => {
                const scoreClass = signal.alphaScore >= 70 ? 'high-score' : 
                                  signal.alphaScore >= 50 ? 'medium-score' : 'low-score';
                const time = new Date(signal.generatedAt).toLocaleString();
                const tvlDisplay = signal.tvl ? (signal.tvl >= 1e9 ? `$${(signal.tvl/1e9).toFixed(1)}B` : `$${(signal.tvl/1e6).toFixed(0)}M`) : 'N/A';
                const tvlChangeClass = (signal.tvlChange24h || 0) >= 0 ? 'positive' : 'negative';
                const priceChangeClass = (signal.priceChange24h || 0) >= 0 ? 'positive' : 'negative';
                const sourceIcon = signal.source === 'ML_SCANNER' ? 'ü§ñ' : 
                                   signal.source === 'ML_DIRECT' ? 'üß†' :
                                   signal.source === 'LIVE_API' ? 'üü¢' : 
                                   signal.source === 'FALLBACK' ? 'üü°' : '‚ö™';
                const sourceTitle = signal.source === 'ML_SCANNER' ? 'ML-Powered API' :
                                    signal.source === 'ML_DIRECT' ? 'ML Feature Analysis' :
                                    'Direct API';

                // ML Features display
                const mlFeatures = signal.mlFeatures || {};
                const mlFeaturesHtml = Object.keys(mlFeatures).length > 0 ? `
                    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-top:0.5rem;font-size:0.7rem;">
                        <span style="background:rgba(0,255,136,${mlFeatures.tvlMomentum/100 * 0.5 + 0.1});padding:2px 6px;border-radius:4px;">TVL: ${mlFeatures.tvlMomentum || 0}%</span>
                        <span style="background:rgba(0,212,255,${(mlFeatures.priceStrength || 50)/100 * 0.5 + 0.1});padding:2px 6px;border-radius:4px;">Price: ${mlFeatures.priceStrength || 0}%</span>
                        <span style="background:rgba(255,170,0,${(mlFeatures.yieldScore || 50)/100 * 0.5 + 0.1});padding:2px 6px;border-radius:4px;">Yield: ${mlFeatures.yieldScore || 0}%</span>
                        <span style="background:rgba(136,136,255,${(mlFeatures.revenueScore || 50)/100 * 0.5 + 0.1});padding:2px 6px;border-radius:4px;">Revenue: ${mlFeatures.revenueScore || 0}%</span>
                        <span style="background:rgba(${100 - (mlFeatures.riskScore || 50)},${mlFeatures.riskScore || 50},100,0.3);padding:2px 6px;border-radius:4px;">Risk: ${mlFeatures.riskScore || 0}%</span>
                        <span style="background:rgba(255,136,255,${(mlFeatures.sentiment || 50)/100 * 0.5 + 0.1});padding:2px 6px;border-radius:4px;">Sentiment: ${mlFeatures.sentiment || 0}%</span>
                    </div>
                ` : '';

                return `
                    <div class="signal-item ${scoreClass}">
                        <div class="signal-header">
                            <span class="signal-protocol">${signal.protocol} <span style="color:#888;font-size:0.8rem;">${signal.token || ''}</span></span>
                            <div style="display:flex;gap:0.5rem;align-items:center;">
                                <span class="signal-score" style="background:${signal.alphaScore >= 70 ? 'rgba(0,255,136,0.3)' : signal.alphaScore >= 50 ? 'rgba(255,170,0,0.3)' : 'rgba(255,68,68,0.3)'}">
                                    Œ± ${signal.alphaScore} | ${signal.confidence}% conf
                                </span>
                                <span title="${sourceTitle}" style="cursor:help;">${sourceIcon}</span>
                            </div>
                        </div>
                        <div class="signal-meta">
                            <span>üìç ${signal.chain}</span>
                            <span>üìä ${signal.type || signal.category}</span>
                            <span class="badge ${signal.action?.toLowerCase().replace(' ', '-')}">${signal.action}</span>
                            <span class="badge ${signal.confidenceLevel?.toLowerCase() || signal.riskLevel?.toLowerCase()}">${signal.confidenceLevel || signal.riskLevel}</span>
                            ${signal.rank ? `<span style="color:#00d4ff;">#${signal.rank}</span>` : ''}
                        </div>
                        <div class="signal-meta" style="margin-top: 0.5rem;">
                            <span>üí∞ TVL: ${tvlDisplay}</span>
                            <span class="${tvlChangeClass}">üìä 24h: ${(signal.tvlChange24h || 0) >= 0 ? '+' : ''}${(signal.tvlChange24h || 0).toFixed(1)}%</span>
                            <span class="${priceChangeClass}">üìà Price: ${(signal.priceChange24h || 0) >= 0 ? '+' : ''}${(signal.priceChange24h || 0).toFixed(1)}%</span>
                            ${signal.apy ? `<span>üíé APY: ${signal.apy.toFixed(1)}%</span>` : ''}
                        </div>
                        <div class="signal-meta" style="margin-top: 0.25rem;">
                            <span>üíµ Entry: $${(signal.entryPrice || 0).toFixed(signal.entryPrice > 100 ? 2 : 4)}</span>
                            <span>üéØ Target: +${signal.expectedReturn}%</span>
                            <span>üìâ Stop: -${(((signal.entryPrice - signal.stopLoss) / signal.entryPrice) * 100).toFixed(1)}%</span>
                        </div>
                        ${mlFeaturesHtml}
                        <div class="signal-reasoning">${signal.reasoning}</div>
                        ${signal.status === 'ACTIVE' ? `
                            <div class="signal-actions">
                                <button class="btn-primary" onclick="executeSignal('${signal.id}')">Execute Trade</button>
                                <button class="btn-secondary" onclick="dismissSignal('${signal.id}')">Dismiss</button>
                            </div>
                        ` : ''}
                        <div class="signal-meta" style="margin-top: 0.5rem; color: #555; font-size: 0.7rem;">
                            <span>‚è∞ ${time}</span>
                            <span>üîó ${signal.chains?.slice(0,3).join(', ') || signal.chain}</span>
                            <span style="color:#666;">via ${signal.source?.replace('_', ' ') || 'API'}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updatePositionsUI() {
            const container = document.getElementById('positionList');
            let positions = getPositions();

            if (currentPositionTab === 'open') {
                positions = positions.filter(p => p.status === 'OPEN');
            } else {
                positions = positions.filter(p => p.status === 'CLOSED');
            }

            if (positions.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>No ${currentPositionTab} positions</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = positions.map(pos => {
                const pnl = pos.status === 'OPEN' ? (pos.unrealizedPnl || 0) : (pos.realizedPnl || 0);
                const pnlPct = pos.status === 'OPEN' ? (pos.unrealizedPnlPct || 0) : (pos.realizedPnlPct || 0);
                const pnlClass = pnl >= 0 ? 'positive' : 'negative';

                return `
                    <div class="position-item">
                        <div class="position-header">
                            <div>
                                <strong>${pos.protocol}</strong>
                                <span class="badge ${pos.positionType.toLowerCase()}">${pos.positionType}</span>
                            </div>
                            <div class="position-pnl ${pnlClass}">
                                ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPct.toFixed(2)}%)
                            </div>
                        </div>
                        <div class="position-details">
                            <div>
                                <label>Entry</label>
                                $${pos.entryPrice.toFixed(4)}
                            </div>
                            <div>
                                <label>Current</label>
                                $${(pos.currentPrice || pos.exitPrice || 0).toFixed(4)}
                            </div>
                            <div>
                                <label>Size</label>
                                $${pos.entryAmount.toFixed(0)}
                            </div>
                        </div>
                        ${pos.status === 'OPEN' ? `
                            <div class="signal-actions">
                                <button class="btn-danger" onclick="closePosition('${pos.id}')">Close Position</button>
                            </div>
                        ` : `
                            <div class="signal-meta" style="margin-top: 0.5rem; color: #555;">
                                <span>Exit: ${pos.exitReason || 'MANUAL'}</span>
                                <span>Closed: ${new Date(pos.exitTime).toLocaleString()}</span>
                            </div>
                        `}
                    </div>
                `;
            }).join('');
        }

        function updateStrategyUI() {
            const positions = getPositions().filter(p => p.status === 'CLOSED');
            
            // Group by type
            const byType = {};
            positions.forEach(p => {
                if (!byType[p.type]) {
                    byType[p.type] = { trades: 0, wins: 0, pnl: 0 };
                }
                byType[p.type].trades++;
                byType[p.type].pnl += p.realizedPnl || 0;
                if ((p.realizedPnl || 0) > 0) byType[p.type].wins++;
            });

            const strategyGrid = document.getElementById('strategyGrid');
            const entries = Object.entries(byType);
            
            if (entries.length === 0) {
                strategyGrid.innerHTML = '<div class="empty-state">Execute trades to see strategy performance</div>';
            } else {
                strategyGrid.innerHTML = entries.map(([type, stats]) => `
                    <div class="strategy-item">
                        <span class="strategy-name">${type}</span>
                        <div class="strategy-stats">
                            <span style="color: ${stats.pnl >= 0 ? '#00ff88' : '#ff4444'}">
                                ${stats.pnl >= 0 ? '+' : ''}$${stats.pnl.toFixed(2)}
                            </span>
                            <span style="color: #888">${((stats.wins/stats.trades)*100).toFixed(0)}% WR</span>
                            <span style="color: #666">${stats.trades} trades</span>
                        </div>
                    </div>
                `).join('');
            }

            // Group by protocol
            const byProtocol = {};
            positions.forEach(p => {
                if (!byProtocol[p.protocol]) {
                    byProtocol[p.protocol] = { trades: 0, wins: 0, pnl: 0 };
                }
                byProtocol[p.protocol].trades++;
                byProtocol[p.protocol].pnl += p.realizedPnl || 0;
                if ((p.realizedPnl || 0) > 0) byProtocol[p.protocol].wins++;
            });

            const protocolGrid = document.getElementById('protocolGrid');
            const protocolEntries = Object.entries(byProtocol).sort((a, b) => b[1].pnl - a[1].pnl);
            
            if (protocolEntries.length === 0) {
                protocolGrid.innerHTML = '<div class="empty-state">Execute trades to see protocol performance</div>';
            } else {
                protocolGrid.innerHTML = protocolEntries.slice(0, 5).map(([protocol, stats]) => `
                    <div class="strategy-item">
                        <span class="strategy-name">${protocol}</span>
                        <div class="strategy-stats">
                            <span style="color: ${stats.pnl >= 0 ? '#00ff88' : '#ff4444'}">
                                ${stats.pnl >= 0 ? '+' : ''}$${stats.pnl.toFixed(2)}
                            </span>
                            <span style="color: #888">${stats.trades} trades</span>
                        </div>
                    </div>
                `).join('');
            }
        }

        function updateChartUI() {
            const history = getPnlHistory();
            
            if (!pnlChart) {
                const ctx = document.getElementById('pnlChart').getContext('2d');
                pnlChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Cumulative P&L',
                            data: [],
                            borderColor: '#00ff88',
                            backgroundColor: 'rgba(0, 255, 136, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointRadius: 4,
                            pointBackgroundColor: '#00ff88'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: {
                                grid: { color: 'rgba(255,255,255,0.05)' },
                                ticks: { color: '#666', maxTicksLimit: 6 }
                            },
                            y: {
                                grid: { color: 'rgba(255,255,255,0.05)' },
                                ticks: { 
                                    color: '#666',
                                    callback: value => '$' + value.toFixed(0)
                                }
                            }
                        }
                    }
                });
            }

            if (history.length > 0) {
                pnlChart.data.labels = history.map(h => new Date(h.date).toLocaleDateString());
                pnlChart.data.datasets[0].data = history.map(h => h.cumulative);
                pnlChart.update();
            }
        }

        // Tab switching
        function switchTab(tab) {
            currentSignalTab = tab;
            document.querySelectorAll('.card:first-of-type .tabs button').forEach((btn, i) => {
                btn.classList.toggle('active', ['active', 'executed', 'all'][i] === tab);
            });
            updateSignalsUI();
        }

        function switchPositionTab(tab) {
            currentPositionTab = tab;
            document.querySelectorAll('.card:nth-child(2) .tabs button').forEach((btn, i) => {
                btn.classList.toggle('active', ['open', 'closed'][i] === tab);
            });
            updatePositionsUI();
        }

        function dismissSignal(signalId) {
            const signals = getSignals();
            const idx = signals.findIndex(s => s.id === signalId);
            if (idx !== -1) {
                signals[idx].status = 'EXPIRED';
                saveSignals(signals);
                refreshData();
                showToast('Signal dismissed');
            }
        }

        function resetPortfolio() {
            if (!confirm('Reset all data? This will clear all signals, positions, and reset portfolio to $100,000.')) return;
            
            localStorage.removeItem(STORAGE_KEYS.SIGNALS);
            localStorage.removeItem(STORAGE_KEYS.POSITIONS);
            localStorage.removeItem(STORAGE_KEYS.PORTFOLIO);
            localStorage.removeItem(STORAGE_KEYS.PNL_HISTORY);
            
            // Clear all price simulations
            Object.values(priceSimulations).forEach(clearInterval);
            
            showToast('‚úÖ Portfolio reset to $100,000');
            refreshData();
        }

        // Utility functions
        function showStatus(message, type = 'info') {
            const banner = document.getElementById('statusBanner');
            if (!banner) return;
            banner.textContent = message;
            banner.className = `status-banner ${type}`;
            banner.style.display = 'flex';
            
            setTimeout(() => {
                banner.style.display = 'none';
            }, 5000);
        }

        function showToast(message) {
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.remove(), 3000);
        }

        // Auto-refresh functionality
        let autoRefreshInterval = null;

        function startAutoRefresh(intervalMs = 5 * 60 * 1000) { // 5 minutes default
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);
            
            autoRefreshInterval = setInterval(() => {
                console.log('Auto-refreshing signals...');
                fetchLiveSignals();
            }, intervalMs);
            
            showToast('üîÑ Auto-refresh enabled (5 min)');
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                showToast('Auto-refresh disabled');
            }
        }

        // Expire old signals
        function cleanupExpiredSignals() {
            const signals = getSignals();
            const now = Date.now();
            const updated = signals.map(s => {
                if (s.status === 'ACTIVE' && new Date(s.expiresAt).getTime() < now) {
                    s.status = 'EXPIRED';
                }
                return s;
            });
            saveSignals(updated);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize data freshness indicator
            updateDataFreshness('cached');
            
            // Cleanup expired signals
            cleanupExpiredSignals();
            
            // Refresh UI
            refreshData();
            
            // Resume price simulation for open positions
            getPositions().filter(p => p.status === 'OPEN').forEach(p => {
                simulatePriceMovement(p.id);
            });

            // Start auto-refresh
            startAutoRefresh();
            
            // Fetch fresh signals on load if no recent data
            const signals = getSignals();
            const recentSignal = signals.find(s => 
                Date.now() - new Date(s.generatedAt).getTime() < 30 * 60 * 1000
            );
            if (!recentSignal) {
                setTimeout(() => fetchLiveSignals(), 1000);
            }
        });
    </script>
</body>
</html>