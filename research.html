<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Info Edge - Research Intelligence | nexxore</title>
  <meta name="description" content="Real-time crypto research, sentiment analysis, and alpha signals powered by autonomous agents.">
  
  <!-- Google Fonts: Space Grotesk, Inter, JetBrains Mono -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Web3 Libraries -->
  <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
  
  <style>
    :root {
      --font-heading: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-body: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
      --bg-primary: #0A0E27;
      --bg-secondary: #0F172A;
      --accent-cyan: #0EA5E9;
      --accent-purple: #8B5CF6;
      --text-primary: #F8FAFC;
      --text-secondary: #CBD5E1;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-body);
      background: linear-gradient(180deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
      color: var(--text-secondary);
      min-height: 100vh;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 32px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 24px;
    }

    .header-right {
      display: flex;
      align-items: center;
    }

    .btn {
      cursor: pointer;
      font-family: inherit;
    }

    .btn-primary {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 212, 255, 0.3);
    }

    .btn-primary.connected {
      background: linear-gradient(135deg, #22c55e, #16a34a);
    }

    .back-link {
      color: #00d4ff;
      text-decoration: none;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: opacity 0.3s;
    }

    .back-link:hover {
      opacity: 0.7;
    }

    .header-title {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-subtitle {
      display: none;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: #22c55e;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 28px 40px;
      max-width: 1920px;
      margin: 0 auto;
      min-height: calc(100vh - 90px);
    }

    .panels-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 24px;
      width: 100%;
    }

    .chat-row {
      width: 100%;
    }

    .panel {
      background: rgba(255, 255, 255, 0.025);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 20px;
      padding: 24px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(20px);
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
    }

    .panel:hover {
      border-color: rgba(0, 212, 255, 0.15);
      box-shadow: 0 8px 32px rgba(0, 212, 255, 0.08);
    }

    .panel.scanner-panel {
      background: linear-gradient(135deg, rgba(14, 165, 233, 0.03) 0%, rgba(139, 92, 246, 0.03) 100%);
      border-color: rgba(0, 212, 255, 0.12);
    }

    .panel.chat-panel {
      min-height: 400px;
    }

    .panel.data-panel {
      min-height: 480px;
      max-height: 520px;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      flex-shrink: 0;
    }

    .panel-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #f8fafc;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel-title-icon {
      font-size: 1.3rem;
    }

    .panel-title-text {
      background: linear-gradient(135deg, #00d4ff, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-family: var(--font-heading);
    }

    .panel-badge {
      font-size: 0.8rem;
      padding: 6px 14px;
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(139, 92, 246, 0.15));
      border-radius: 20px;
      color: #00d4ff;
      font-weight: 600;
      font-family: var(--font-mono);
      border: 1px solid rgba(0, 212, 255, 0.2);
    }

    /* Scrollable Content Area */
    .scrollable-content {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 8px;
      margin-right: -8px;
      scroll-behavior: smooth;
    }

    .scrollable-content::-webkit-scrollbar {
      width: 6px;
    }

    .scrollable-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
    }

    .scrollable-content::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(0, 212, 255, 0.4), rgba(139, 92, 246, 0.4));
      border-radius: 10px;
    }

    .scrollable-content::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(0, 212, 255, 0.6), rgba(139, 92, 246, 0.6));
    }

    /* News Panel */
    .news-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .news-item {
      background: rgba(255, 255, 255, 0.02);
      padding: 16px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .news-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: linear-gradient(180deg, #00d4ff, #8b5cf6);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .news-item:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(0, 212, 255, 0.2);
      transform: translateX(6px);
    }

    .news-item:hover::before {
      opacity: 1;
    }

    .news-source {
      font-size: 0.7rem;
      color: #00d4ff;
      font-weight: 700;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .news-source::before {
      content: '‚óè';
      font-size: 0.5rem;
      color: #22c55e;
      animation: pulse 2s infinite;
    }

    .news-title {
      font-size: 0.92rem;
      font-weight: 500;
      margin-bottom: 10px;
      line-height: 1.5;
      color: #f1f5f9;
    }

    .news-meta {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .news-sentiment {
      display: inline-flex;
      align-items: center;
      font-size: 0.7rem;
      padding: 4px 10px;
      border-radius: 8px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .sentiment-bullish {
      background: rgba(34, 197, 94, 0.2);
      color: #22c55e;
    }

    .sentiment-bearish {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .sentiment-neutral {
      background: rgba(156, 163, 175, 0.2);
      color: #9ca3af;
    }

    /* Chat Panel */
    .chat-messages {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 20px;
      padding-right: 10px;
      min-height: 250px;
      scroll-behavior: smooth;
    }

    .chat-messages::-webkit-scrollbar {
      width: 6px;
    }

    .chat-messages::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
    }

    .chat-messages::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(147, 51, 234, 0.4), rgba(0, 212, 255, 0.4));
      border-radius: 10px;
    }

    .message {
      padding: 14px 18px;
      border-radius: 16px;
      max-width: 80%;
      line-height: 1.6;
      font-size: 0.92rem;
      animation: messageSlide 0.3s ease;
    }

    @keyframes messageSlide {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.user {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.12), rgba(0, 212, 255, 0.08));
      border: 1px solid rgba(0, 212, 255, 0.25);
      align-self: flex-end;
      margin-left: auto;
      border-radius: 16px 16px 4px 16px;
    }

    .message.ai {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.12), rgba(147, 51, 234, 0.08));
      border: 1px solid rgba(147, 51, 234, 0.25);
      align-self: flex-start;
      border-radius: 16px 16px 16px 4px;
    }

    .message.ai strong {
      color: #a78bfa;
      font-weight: 600;
    }

    .chat-input-container {
      display: flex;
      gap: 12px;
      padding-top: 16px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      flex-shrink: 0;
    }

    .chat-input {
      flex: 1;
      padding: 14px 20px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      color: #f1f5f9;
      font-size: 0.95rem;
      font-family: var(--font-body);
      transition: all 0.3s ease;
    }

    .chat-input::placeholder {
      color: #64748b;
    }

    .chat-input:focus {
      outline: none;
      border-color: rgba(0, 212, 255, 0.4);
      background: rgba(255, 255, 255, 0.06);
      box-shadow: 0 0 20px rgba(0, 212, 255, 0.1);
    }

    .chat-send {
      padding: 14px 28px;
      background: linear-gradient(135deg, #00d4ff, #8b5cf6);
      border: none;
      border-radius: 14px;
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2);
    }

    .chat-send:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.3);
    }

    .chat-send:active {
      transform: translateY(0);
    }

    /* Trending Panel */
    .trending-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .trending-item {
      background: rgba(255, 255, 255, 0.02);
      padding: 16px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      transition: all 0.3s ease;
      position: relative;
    }

    .trending-item:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(139, 92, 246, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(139, 92, 246, 0.1);
    }

    .trending-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .trending-symbol {
      font-size: 1.05rem;
      font-weight: 700;
      font-family: var(--font-heading);
      background: linear-gradient(135deg, #00d4ff, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .trending-rank {
      font-size: 0.75rem;
      font-weight: 600;
      font-family: var(--font-mono);
      color: #fbbf24;
      background: rgba(251, 191, 36, 0.1);
      padding: 4px 12px;
      border-radius: 10px;
      border: 1px solid rgba(251, 191, 36, 0.2);
    }

    .trending-name {
      font-size: 0.85rem;
      color: #94a3b8;
      margin-bottom: 12px;
      font-weight: 400;
    }

    .trending-stats {
      display: flex;
      gap: 16px;
      font-size: 0.8rem;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.04);
    }

    .stat-item {
      color: #64748b;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .stat-value {
      color: #e2e8f0;
      font-weight: 600;
      font-family: var(--font-mono);
    }

    .loading {
      text-align: center;
      padding: 40px 20px;
      color: #64748b;
      font-size: 0.95rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .loading::before {
      content: '';
      width: 32px;
      height: 32px;
      border: 3px solid rgba(0, 212, 255, 0.15);
      border-top-color: #00d4ff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .error {
      background: rgba(239, 68, 68, 0.08);
      border: 1px solid rgba(239, 68, 68, 0.2);
      color: #f87171;
      padding: 16px 20px;
      border-radius: 12px;
      margin: 10px 0;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .error::before {
      content: '‚ö†Ô∏è';
    }

    /* Alpha Scanner Styles */
    .scanner-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .scanner-controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .scanner-btn {
      padding: 10px 18px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      color: #94a3b8;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: var(--font-body);
    }

    .scanner-btn:hover {
      background: rgba(0, 212, 255, 0.08);
      border-color: rgba(0, 212, 255, 0.25);
      color: #00d4ff;
      transform: translateY(-1px);
    }

    .scanner-btn.active {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(139, 92, 246, 0.15));
      border-color: #00d4ff;
      color: #00d4ff;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.15);
    }

    .scanner-btn.refresh-btn {
      background: rgba(34, 197, 94, 0.08);
      border-color: rgba(34, 197, 94, 0.25);
      color: #22c55e;
    }

    .scanner-btn.refresh-btn:hover {
      background: rgba(34, 197, 94, 0.15);
      color: #4ade80;
    }

    .signal-card {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 18px;
      padding: 22px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .signal-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #00d4ff, #8b5cf6, #00d4ff);
      background-size: 200% 100%;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .signal-card:hover {
      background: rgba(255, 255, 255, 0.04);
      border-color: rgba(0, 212, 255, 0.2);
      transform: translateY(-4px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
    }

    .signal-card:hover::before {
      opacity: 1;
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    .signal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
    }

    .signal-type-badge {
      font-size: 0.72rem;
      padding: 5px 12px;
      border-radius: 8px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      font-family: var(--font-mono);
    }

    .signal-type-badge.oi_divergence {
      background: rgba(139, 92, 246, 0.15);
      color: #a78bfa;
      border: 1px solid rgba(139, 92, 246, 0.25);
    }

    .signal-type-badge.tvl_lag {
      background: rgba(34, 197, 94, 0.15);
      color: #4ade80;
      border: 1px solid rgba(34, 197, 94, 0.25);
    }

    .signal-type-badge.funding_divergence {
      background: rgba(251, 191, 36, 0.15);
      color: #fcd34d;
      border: 1px solid rgba(251, 191, 36, 0.25);
    }
    
    /* New positioning-based trade types */
    .signal-type-badge.fade_trade {
      background: rgba(239, 68, 68, 0.15);
      color: #f87171;
      border: 1px solid rgba(239, 68, 68, 0.25);
    }
    
    .signal-type-badge.squeeze_setup {
      background: rgba(14, 165, 233, 0.15);
      color: #38bdf8;
      border: 1px solid rgba(14, 165, 233, 0.25);
    }
    
    .signal-type-badge.vol_expansion {
      background: rgba(168, 85, 247, 0.15);
      color: #c084fc;
      border: 1px solid rgba(168, 85, 247, 0.25);
    }
    
    /* Conviction indicator */
    .conviction-badge {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 6px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-left: 6px;
    }
    
    .conviction-badge.high {
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
    }
    
    .conviction-badge.medium {
      background: rgba(251, 191, 36, 0.2);
      color: #fcd34d;
    }
    
    .conviction-badge.low {
      background: rgba(148, 163, 184, 0.2);
      color: #94a3b8;
    }

    .signal-asset {
      font-family: var(--font-heading);
      font-size: 1.15rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-top: 8px;
    }

    .confidence-meter {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }

    .confidence-bar {
      width: 70px;
      height: 6px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 3px;
      overflow: hidden;
    }

    .confidence-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.5s ease;
    }

    .confidence-fill.high { background: linear-gradient(90deg, #22c55e, #4ade80); }
    .confidence-fill.medium { background: linear-gradient(90deg, #fbbf24, #fcd34d); }
    .confidence-fill.low { background: linear-gradient(90deg, #64748b, #94a3b8); }

    .confidence-score {
      font-family: var(--font-mono);
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--text-primary);
    }

    .signal-context {
      font-size: 0.88rem;
      color: #94a3b8;
      line-height: 1.7;
      margin-bottom: 16px;
      padding: 14px 16px;
      background: rgba(0, 0, 0, 0.25);
      border-radius: 12px;
      border-left: 4px solid rgba(0, 212, 255, 0.4);
    }

    .signal-section {
      margin-bottom: 14px;
    }

    .signal-section-title {
      font-size: 0.72rem;
      font-weight: 600;
      color: #00d4ff;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      margin-bottom: 6px;
      font-family: var(--font-heading);
    }

    .signal-section-content {
      font-size: 0.88rem;
      color: #cbd5e1;
      line-height: 1.6;
    }

    .trade-expression {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.08), rgba(34, 197, 94, 0.04));
      border: 1px solid rgba(34, 197, 94, 0.2);
      border-radius: 12px;
      padding: 14px 16px;
      margin: 14px 0;
    }

    .trade-expression .signal-section-title {
      color: #4ade80;
    }

    .trade-expression .signal-section-content {
      font-family: var(--font-mono);
      color: #4ade80;
      font-weight: 500;
      font-size: 0.9rem;
    }

    .signal-meta {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      padding-top: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.04);
    }

    .meta-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .meta-label {
      font-size: 0.7rem;
      color: #475569;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 500;
    }

    .meta-value {
      font-size: 0.85rem;
      color: #94a3b8;
      font-family: var(--font-mono);
    }

    .meta-value.risk { color: #f87171; }
    .meta-value.invalidation { color: #fbbf24; }

    .signal-expand-btn {
      width: 100%;
      padding: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.04);
      border-radius: 10px;
      color: #475569;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 14px;
      font-weight: 500;
    }

    .signal-expand-btn:hover {
      background: rgba(0, 212, 255, 0.06);
      border-color: rgba(0, 212, 255, 0.15);
      color: #00d4ff;
    }

    .signal-details {
      display: none;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px dashed rgba(255, 255, 255, 0.08);
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .signal-details.expanded {
      display: block;
    }

    .no-signals {
      text-align: center;
      padding: 60px 30px;
      color: #475569;
      grid-column: 1 / -1;
    }

    .no-signals-icon {
      font-size: 3.5rem;
      margin-bottom: 16px;
      opacity: 0.4;
    }

    .no-signals p {
      margin: 0;
    }

    .no-signals p:first-of-type {
      font-size: 1.1rem;
      color: #64748b;
      font-weight: 500;
    }

    /* Data Freshness Indicator */
    .data-freshness {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      margin-top: 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      font-size: 0.8rem;
      color: #64748b;
      flex-shrink: 0;
    }

    .freshness-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #64748b;
      transition: background 0.3s;
    }

    .freshness-dot.live {
      background: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
      animation: pulse 2s infinite;
    }

    .freshness-dot.stale {
      background: #fbbf24;
    }

    .freshness-dot.error {
      background: #ef4444;
    }

    .freshness-text {
      flex: 1;
    }

    .freshness-countdown {
      font-family: var(--font-mono);
      color: #475569;
      font-size: 0.75rem;
    }

    .data-source-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.65rem;
      padding: 3px 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      color: #475569;
      margin-left: 8px;
    }

    .data-source-badge.live {
      background: rgba(34, 197, 94, 0.1);
      color: #22c55e;
    }

    @media (max-width: 1400px) {
      .panels-row {
        grid-template-columns: repeat(2, 1fr);
      }
      .panels-row .panel:last-child {
        grid-column: 1 / -1;
      }
      .container {
        padding: 24px 28px;
      }
    }

    @media (max-width: 1024px) {
      .panels-row {
        grid-template-columns: 1fr;
      }
      .alpha-signals-grid {
        grid-template-columns: 1fr !important;
      }
      .scanner-controls {
        flex-wrap: wrap;
        justify-content: center;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 16px;
        gap: 16px;
      }
      .header {
        padding: 14px 16px;
      }
      .header-title {
        font-size: 1.2rem;
      }
      .signal-meta {
        grid-template-columns: 1fr;
      }
      .panel {
        padding: 18px;
        border-radius: 16px;
      }
      .panel.data-panel {
        min-height: 400px;
        max-height: 450px;
      }
    }

    /* Insights specific styles */
    .insights-list {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .insight-item {
      background: rgba(255, 255, 255, 0.02);
      padding: 18px 20px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      transition: all 0.3s ease;
      position: relative;
    }

    .insight-item::after {
      content: '';
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 60%;
      background: linear-gradient(180deg, #00d4ff, #8b5cf6);
      border-radius: 2px;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .insight-item:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(0, 212, 255, 0.2);
      transform: translateX(4px);
    }

    .insight-item:hover::after {
      opacity: 1;
    }

    .insight-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .insight-protocol {
      font-size: 1.05rem;
      font-weight: 700;
      font-family: var(--font-heading);
      background: linear-gradient(135deg, #00d4ff, #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .insight-confidence {
      font-size: 0.8rem;
      padding: 5px 12px;
      border-radius: 10px;
      font-weight: 600;
      font-family: var(--font-mono);
    }

    .confidence-high {
      background: rgba(34, 197, 94, 0.12);
      color: #22c55e;
      border: 1px solid rgba(34, 197, 94, 0.2);
    }

    .confidence-medium {
      background: rgba(251, 191, 36, 0.12);
      color: #fbbf24;
      border: 1px solid rgba(251, 191, 36, 0.2);
    }

    .confidence-low {
      background: rgba(156, 163, 175, 0.12);
      color: #9ca3af;
      border: 1px solid rgba(156, 163, 175, 0.2);
    }

    .insight-summary {
      font-size: 0.88rem;
      color: #94a3b8;
      margin-bottom: 14px;
      line-height: 1.6;
    }

    .insight-metrics {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      font-size: 0.8rem;
    }

    .metric-item {
      background: rgba(255, 255, 255, 0.03);
      padding: 10px 14px;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    .metric-label {
      color: #64748b;
      font-weight: 500;
    }

    .metric-value {
      color: #e2e8f0;
      font-weight: 600;
      font-family: var(--font-mono);
    }

    .metric-value.positive {
      color: #4ade80;
    }

    .metric-value.negative {
      color: #f87171;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-left">
      <div>
        <span class="header-title">Info Edge</span>
        <span class="header-subtitle">Research Intelligence Dashboard</span>
      </div>
    </div>
    <div class="header-right">
      <div id="portfolioHealth" style="display: none; margin-right: 20px; padding: 8px 16px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; font-size: 0.9rem;">
        <span style="color: #9ca3af;">Health Score:</span>
        <span id="healthScore" style="color: #22c55e; font-weight: 600; margin-left: 8px;">--</span>
      </div>
      <button id="connectWalletBtn" class="btn btn-primary" style="padding: 10px 20px; border: none; border-radius: 8px; background: linear-gradient(135deg, #00d4ff, #0099ff); color: white; font-weight: 600; cursor: pointer; transition: all 0.3s;">
        Connect Wallet
      </button>
    </div>
  </div>

  <div class="container">
    <!-- Alpha Scanner Panel - Full Width -->
    <div class="panel scanner-panel">
      <div class="panel-header">
        <div style="display: flex; align-items: center; gap: 14px;">
          <div class="panel-title">
            <span class="panel-title-icon">üéØ</span>
            <span class="panel-title-text">Alpha Scanner</span>
          </div>
          <div class="panel-badge" id="signalCount">0 signals</div>
        </div>
        <div class="scanner-controls">
          <button class="scanner-btn active" data-type="all" onclick="filterSignals('all')">All</button>
          <button class="scanner-btn" data-type="fade_trade" onclick="filterSignals('fade_trade')">Fade Trade</button>
          <button class="scanner-btn" data-type="squeeze_setup" onclick="filterSignals('squeeze_setup')">Squeeze</button>
          <button class="scanner-btn" data-type="vol_expansion" onclick="filterSignals('vol_expansion')">Vol Expand</button>
          <button class="scanner-btn" data-type="tvl_lag" onclick="filterSignals('tvl_lag')">TVL Lag</button>
          <button class="scanner-btn refresh-btn" onclick="runAlphaScan(true)">‚Üª Refresh</button>
        </div>
      </div>
      <div class="scrollable-content" style="max-height: 520px;">
        <div id="alphaSignals" class="alpha-signals-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(420px, 1fr)); gap: 20px;">
          <div class="loading">Scanning for alpha signals...</div>
        </div>
      </div>
      <!-- Data Freshness Indicator -->
      <div class="data-freshness" id="scannerFreshness">
        <span class="freshness-dot"></span>
        <span class="freshness-text">Initializing...</span>
        <span class="freshness-countdown" id="refreshCountdown"></span>
      </div>
    </div>

    <!-- Three Column Data Panels -->
    <div class="panels-row">
      <!-- Research Insights Panel -->
      <div class="panel data-panel">
        <div class="panel-header">
          <div class="panel-title">
            <span class="panel-title-icon">üìä</span>
            <span class="panel-title-text">Protocol Insights</span>
          </div>
          <div class="panel-badge" id="insightsCount">0</div>
        </div>
        <div class="scrollable-content">
          <div class="insights-list" id="insightsList">
            <div class="loading">Analyzing protocols...</div>
          </div>
        </div>
      </div>

      <!-- News Panel -->
      <div class="panel data-panel">
        <div class="panel-header">
          <div class="panel-title">
            <span class="panel-title-icon">üì∞</span>
            <span class="panel-title-text">Latest News</span>
          </div>
          <div class="panel-badge" id="newsCount">0</div>
        </div>
        <div class="scrollable-content">
          <div class="news-list" id="newsList">
            <div class="loading">Loading news...</div>
          </div>
        </div>
      </div>

      <!-- Trending Panel -->
      <div class="panel data-panel">
        <div class="panel-header">
          <div class="panel-title">
            <span class="panel-title-icon">üî•</span>
            <span class="panel-title-text">Trending</span>
          </div>
          <div class="panel-badge" id="trendingCount">0</div>
        </div>
        <div class="scrollable-content">
          <div class="trending-list" id="trendingList">
            <div class="loading">Loading trending tokens...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Chat Panel - Full Width -->
    <div class="chat-row">
      <div class="panel chat-panel">
        <div class="panel-header">
          <div class="panel-title">
            <span class="panel-title-icon">üí¨</span>
            <span class="panel-title-text">AI Research Assistant</span>
          </div>
          <div class="panel-badge" style="background: rgba(34, 197, 94, 0.15); color: #22c55e; border-color: rgba(34, 197, 94, 0.2);">Online</div>
        </div>
        <div class="chat-messages" id="chatMessages">
          <div class="message ai">
            <strong>Info Edge:</strong> Hello! I'm your research agent. Ask me about crypto trends, tokens, or market sentiment. I have access to real-time news and data.
          </div>
        </div>
        <div class="chat-input-container">
          <input type="text" class="chat-input" id="chatInput" placeholder="Ask about crypto trends, sentiment, or specific tokens..." />
          <button class="chat-send" id="chatSend">Send</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Use relative path for API in production, localhost in development
    const API_BASE = window.location.hostname === 'localhost' 
      ? 'http://localhost:3000/api' 
      : '/api';
    
    console.log('üöÄ Research Dashboard Initialized');
    console.log('üì° API Base URL:', API_BASE);

    // Fetch and display research insights
    async function loadInsights() {
      console.log('üéØ Loading research insights...');
      try {
        const response = await fetch(`${API_BASE}/research/insights?protocols=aave,curve,uniswap,compound`);
        console.log('üì• Insights response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ Insights data loaded:', data);
        
        const insightsList = document.getElementById('insightsList');
        const insightsCount = document.getElementById('insightsCount');
        
        if (data.error) {
          insightsList.innerHTML = `<div class="error">${data.error}</div>`;
          console.error('‚ùå API returned error:', data.error);
        } else if (data.insights && data.insights.length > 0) {
          insightsCount.textContent = data.insights.length;
          insightsList.innerHTML = data.insights.map(insight => {
            const confidenceClass = insight.confidence >= 0.6 ? 'high' : 
                                   insight.confidence >= 0.3 ? 'medium' : 'low';
            const confidenceLabel = insight.confidence >= 0.6 ? 'High' : 
                                   insight.confidence >= 0.3 ? 'Medium' : 'Low';
            
            return `
              <div class="insight-item">
                <div class="insight-header">
                  <div class="insight-protocol">${insight.protocol}</div>
                  <div class="insight-confidence confidence-${confidenceClass}">
                    ${confidenceLabel} ${(insight.confidence * 100).toFixed(0)}%
                  </div>
                </div>
                <div class="insight-summary">${insight.summary || 'No summary available'}</div>
                <div class="insight-metrics">
                  ${insight.signals && insight.signals.defi && insight.signals.defi.length > 0 ? `
                    <div class="metric-item">
                      <span class="metric-label">TVL</span>
                      <span class="metric-value">$${(insight.signals.defi[0].tvl / 1e9).toFixed(2)}B</span>
                    </div>
                    <div class="metric-item">
                      <span class="metric-label">7d Change</span>
                      <span class="metric-value ${insight.signals.defi[0].tvlChange7d >= 0 ? 'positive' : 'negative'}">
                        ${insight.signals.defi[0].tvlChange7d >= 0 ? '+' : ''}${insight.signals.defi[0].tvlChange7d.toFixed(2)}%
                      </span>
                    </div>
                  ` : `
                    <div class="metric-item">
                      <span class="metric-label">Status</span>
                      <span class="metric-value">Analyzing...</span>
                    </div>
                  `}
                  <div class="metric-item">
                    <span class="metric-label">Signals</span>
                    <span class="metric-value">${Object.values(insight.signals || {}).flat().length}</span>
                  </div>
                  <div class="metric-item">
                    <span class="metric-label">Insights</span>
                    <span class="metric-value">${insight.insights?.length || 0}</span>
                  </div>
                </div>
              </div>
            `;
          }).join('');
          console.log('‚úÖ Insights rendered:', data.insights.length, 'items');
        } else {
          insightsList.innerHTML = '<div class="error">No insights available</div>';
          console.warn('‚ö†Ô∏è No insights data found');
        }
      } catch (error) {
        console.error('‚ùå Error loading insights:', error);
        document.getElementById('insightsList').innerHTML = `<div class="error">Failed to load insights: ${error.message}</div>`;
      }
    }

    // Fetch and display news
    async function loadNews() {
      console.log('üì∞ Loading news...');
      try {
        const response = await fetch(`${API_BASE}/news`);
        console.log('üì• News response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ News data loaded:', data);
        
        const newsList = document.getElementById('newsList');
        const newsCount = document.getElementById('newsCount');
        
        if (data.error) {
          newsList.innerHTML = `<div class="error">${data.error}</div>`;
          console.error('‚ùå API returned error:', data.error);
        } else if (data.news && data.news.length > 0) {
          newsCount.textContent = data.news.length;
          newsList.innerHTML = data.news.map(item => `
            <div class="news-item" onclick="window.open('${item.url}', '_blank')">
              <div class="news-source">${item.source}</div>
              <div class="news-title">${item.title}</div>
              <span class="news-sentiment sentiment-${item.sentiment || 'neutral'}">${item.sentiment || 'neutral'}</span>
            </div>
          `).join('');
          console.log('‚úÖ News rendered:', data.news.length, 'items');
        } else {
          newsList.innerHTML = '<div class="error">No news available</div>';
          console.warn('‚ö†Ô∏è No news data found');
        }
      } catch (error) {
        console.error('‚ùå Error loading news:', error);
        document.getElementById('newsList').innerHTML = `<div class="error">Failed to load news: ${error.message}</div>`;
      }
    }

    // Fetch and display trending tokens
    async function loadTrending() {
      console.log('üî• Loading trending tokens...');
      try {
        const response = await fetch(`${API_BASE}/trending`);
        console.log('üì• Trending response status:', response.status);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ Trending data loaded:', data);
        
        const trendingList = document.getElementById('trendingList');
        const trendingCount = document.getElementById('trendingCount');
        
        if (data.error) {
          trendingList.innerHTML = `<div class="error">${data.error}</div>`;
          console.error('‚ùå API returned error:', data.error);
        } else if (data.trending && data.trending.length > 0) {
          trendingCount.textContent = data.trending.length;
          trendingList.innerHTML = data.trending.map((token, index) => `
            <div class="trending-item">
              <div class="trending-header">
                <div class="trending-symbol">${token.symbol}</div>
                <div class="trending-rank">#${index + 1}</div>
              </div>
              <div class="trending-name">${token.name}</div>
              <div class="trending-stats">
                <div class="stat-item">Rank: <span class="stat-value">${token.market_cap_rank || 'N/A'}</span></div>
              </div>
            </div>
          `).join('');
          console.log('‚úÖ Trending rendered:', data.trending.length, 'tokens');
        } else {
          trendingList.innerHTML = '<div class="error">No trending data available</div>';
          console.warn('‚ö†Ô∏è No trending data found');
        }
      } catch (error) {
        console.error('‚ùå Error loading trending:', error);
        document.getElementById('trendingList').innerHTML = `<div class="error">Failed to load trending: ${error.message}</div>`;
      }
    }

    // Chat functionality
    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const messages = document.getElementById('chatMessages');
      const message = input.value.trim();
      
      if (!message) return;
      
      // Add user message
      const userMsg = document.createElement('div');
      userMsg.className = 'message user';
      userMsg.textContent = message;
      messages.appendChild(userMsg);
      
      input.value = '';
      messages.scrollTop = messages.scrollHeight;
      
      // Send to AI
      try {
        const response = await fetch(`${API_BASE}/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message })
        });
        
        const data = await response.json();
        
        // Add AI response
        const aiMsg = document.createElement('div');
        aiMsg.className = 'message ai';
        aiMsg.innerHTML = `<strong>Info Edge:</strong> ${data.response}`;
        messages.appendChild(aiMsg);
        
        messages.scrollTop = messages.scrollHeight;
      } catch (error) {
        console.error('Error sending message:', error);
        const errorMsg = document.createElement('div');
        errorMsg.className = 'message ai error';
        errorMsg.innerHTML = '<strong>Error:</strong> Failed to get response';
        messages.appendChild(errorMsg);
      }
    }

    // Event listeners
    document.getElementById('chatSend').addEventListener('click', sendMessage);
    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    // Initial load
    loadInsights();
    loadNews();
    loadTrending();
    runAlphaScan();

    // ===============================
    // ALPHA SCANNER FUNCTIONALITY
    // ===============================
    
    let allAlphaSignals = [];
    let currentFilter = 'all';
    let lastScanTimestamp = null;
    let scanSource = 'initializing';
    let refreshInterval = null;
    let countdownInterval = null;
    const AUTO_REFRESH_MS = 2 * 60 * 1000; // 2 minutes for real-time feel

    // Update freshness indicator
    function updateFreshnessIndicator(status, message, timestamp = null) {
      const freshness = document.getElementById('scannerFreshness');
      const dot = freshness.querySelector('.freshness-dot');
      const text = freshness.querySelector('.freshness-text');
      
      dot.className = 'freshness-dot ' + status;
      text.innerHTML = message;
      
      if (timestamp) {
        lastScanTimestamp = timestamp;
      }
    }

    // Start countdown timer
    function startCountdown() {
      if (countdownInterval) clearInterval(countdownInterval);
      
      let secondsLeft = AUTO_REFRESH_MS / 1000;
      const countdownEl = document.getElementById('refreshCountdown');
      
      countdownInterval = setInterval(() => {
        secondsLeft--;
        if (secondsLeft <= 0) {
          countdownEl.textContent = 'Refreshing...';
          return;
        }
        const mins = Math.floor(secondsLeft / 60);
        const secs = secondsLeft % 60;
        countdownEl.textContent = `Next refresh: ${mins}:${secs.toString().padStart(2, '0')}`;
      }, 1000);
    }

    // Run alpha scan with real API
    async function runAlphaScan(refresh = false) {
      console.log('üéØ Running alpha scan...');
      const container = document.getElementById('alphaSignals');
      const countBadge = document.getElementById('signalCount');
      
      container.innerHTML = '<div class="loading">Scanning markets for anomalies...</div>';
      updateFreshnessIndicator('', 'Fetching live data from CoinGecko & DeFiLlama...');
      
      try {
        // Try real API first
        const apiUrl = `${API_BASE}/research/alpha-scan${refresh ? '?refresh=true' : ''}`;
        console.log('üì° Calling API:', apiUrl);
        
        const response = await fetch(apiUrl, { 
          timeout: 15000,
          headers: { 'Accept': 'application/json' }
        });
        
        if (!response.ok) {
          throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('‚úÖ API response:', data);
        
        if (data.signals && data.signals.length >= 0) {
          allAlphaSignals = data.signals;
          scanSource = 'live';
          
          const cached = data.cached ? ' (cached)' : '';
          const timestamp = data.metadata?.timestamp || new Date().toISOString();
          
          countBadge.innerHTML = `${data.signals.length} signals <span class="data-source-badge live">‚óè LIVE</span>`;
          updateFreshnessIndicator('live', 
            `Live data from CoinGecko & DeFiLlama${cached} ‚Ä¢ Updated ${formatTimestamp(timestamp)}`,
            timestamp
          );
          
          renderSignals(data.signals);
          startCountdown();
          
          console.log('‚úÖ Alpha scan complete (LIVE):', data.signals.length, 'signals');
          return;
        }
      } catch (apiError) {
        console.warn('‚ö†Ô∏è API unavailable, using real-time fallback:', apiError.message);
      }
      
      // Fallback: Direct API calls to CoinGecko & DeFiLlama
      try {
        updateFreshnessIndicator('', 'API unavailable, fetching directly from data sources...');
        const signals = await fetchDirectSignals();
        
        allAlphaSignals = signals;
        scanSource = 'direct';
        
        countBadge.innerHTML = `${signals.length} signals <span class="data-source-badge live">‚óè DIRECT</span>`;
        updateFreshnessIndicator('live', 
          `Direct feed from CoinGecko & DeFiLlama ‚Ä¢ Updated ${formatTimestamp(new Date().toISOString())}`,
          new Date().toISOString()
        );
        
        renderSignals(signals);
        startCountdown();
        
        console.log('‚úÖ Alpha scan complete (DIRECT):', signals.length, 'signals');
      } catch (fallbackError) {
        console.error('‚ùå All data sources failed:', fallbackError);
        
        // Last resort: Use demo data
        const demoSignals = generateDemoSignals();
        allAlphaSignals = demoSignals;
        scanSource = 'demo';
        
        countBadge.innerHTML = `${demoSignals.length} signals <span class="data-source-badge">DEMO</span>`;
        updateFreshnessIndicator('stale', 
          'Using demo data (live APIs unavailable) ‚Ä¢ Simulated signals for demonstration'
        );
        
        renderSignals(demoSignals);
        startCountdown();
      }
    }

    // Fetch signals directly from public APIs with advanced positioning analysis
    async function fetchDirectSignals() {
      const signals = [];
      
      // Fetch from CoinGecko with comprehensive data
      const cgResponse = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin,ethereum,solana,pendle,gmx,aave,arbitrum,optimism&order=market_cap_desc&sparkline=true&price_change_percentage=1h,24h,7d');
      
      if (!cgResponse.ok) throw new Error('CoinGecko unavailable');
      
      const marketData = await cgResponse.json();
      console.log('üìä CoinGecko data:', marketData.length, 'assets');
      
      // Fetch TVL from DeFiLlama
      const protocols = ['pendle', 'gmx', 'aave', 'lido', 'uniswap'];
      const tvlPromises = protocols.map(p => 
        fetch(`https://api.llama.fi/protocol/${p}`)
          .then(r => r.ok ? r.json() : null)
          .catch(() => null)
      );
      
      const tvlData = await Promise.all(tvlPromises);
      console.log('üìà DeFiLlama data loaded');
      
      // === POSITIONING-BASED SIGNAL ANALYSIS ===
      for (const coin of marketData) {
        const sparkline = coin.sparkline_in_7d?.price || [];
        if (sparkline.length < 24) continue;
        
        // Multi-period funding proxy analysis
        const positioning = analyzePositioningFromSparkline(sparkline, coin);
        if (!positioning) continue;
        
        // Calculate volatility metrics
        const volatility = calculateSparklineVolatility(sparkline);
        const recentVol = calculateSparklineVolatility(sparkline.slice(-24));
        const volCompression = volatility > 0 ? recentVol / volatility : 1;
        
        // Classify trade setup
        const tradeSetup = classifyTradeSetupFrontend(positioning, {
          current: recentVol,
          historical: volatility,
          compression: volCompression
        }, coin);
        
        if (tradeSetup.valid && tradeSetup.conviction !== 'LOW') {
          const signal = generatePositioningSignalFrontend(coin, positioning, tradeSetup, sparkline);
          signals.push(signal);
        }
      }
      
      // === TVL LAG ANALYSIS ===
      for (let i = 0; i < protocols.length; i++) {
        const protocol = protocols[i];
        const tvl = tvlData[i];
        const price = marketData.find(m => m.id === protocol || m.symbol.toLowerCase() === protocol);
        
        if (!tvl || !price) continue;
        
        const tvlHistory = tvl.tvl || [];
        if (tvlHistory.length < 8) continue;
        
        const currentTvl = tvlHistory[tvlHistory.length - 1]?.totalLiquidityUSD || 0;
        const tvl7dAgo = tvlHistory[tvlHistory.length - 8]?.totalLiquidityUSD || currentTvl;
        const tvlChange7d = tvl7dAgo > 0 ? ((currentTvl - tvl7dAgo) / tvl7dAgo) * 100 : 0;
        const priceChange7d = price.price_change_percentage_7d_in_currency || 0;
        const divergence = tvlChange7d - priceChange7d;
        
        // REJECT: Weak divergence
        if (divergence > 8 && tvlChange7d > 5) {
          signals.push({
            signalType: 'TVL_LAG',
            tradeType: 'TVL_LAG',
            asset: `${tvl.name} (${price.symbol.toUpperCase()})`,
            direction: 'LONG',
            conviction: divergence > 15 ? 'HIGH' : 'MEDIUM',
            marketContext: `${tvl.name} TVL: $${formatNumber(currentTvl)}. 7d TVL change: ${tvlChange7d > 0 ? '+' : ''}${tvlChange7d.toFixed(1)}%. Token price 7d: ${priceChange7d > 0 ? '+' : ''}${priceChange7d.toFixed(1)}%.`,
            observedAnomaly: `TVL growth (${tvlChange7d > 0 ? '+' : ''}${tvlChange7d.toFixed(1)}%) outpacing token price (${priceChange7d.toFixed(1)}%). Divergence: ${divergence.toFixed(1)}%.`,
            whyMatters: 'Capital flowing into protocol but token price lagging. Protocol fundamentals improving faster than market recognition.',
            tradeExpression: `Long ${price.symbol.toUpperCase()} spot. Target: ${(divergence * 0.5).toFixed(1)}% catch-up move.`,
            timeHorizon: '1-2 weeks',
            keyRisks: 'Mercenary TVL, token inflation, smart contract risk',
            invalidationLevel: `TVL drops >10% or price below $${(price.current_price * 0.9).toFixed(2)}`,
            confidenceScore: Math.min(75, 35 + Math.floor(divergence * 2)),
            timestamp: new Date().toISOString(),
            rawData: { tvl: currentTvl, tvlChange7d, priceChange7d, divergence }
          });
        }
      }
      
      // Sort by confidence and return top signals
      return signals
        .filter(s => s.confidenceScore >= 45) // Reject weak signals
        .sort((a, b) => {
          // Sort by conviction then confidence
          const convOrder = { 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
          const aConv = convOrder[a.conviction] || 2;
          const bConv = convOrder[b.conviction] || 2;
          if (bConv !== aConv) return bConv - aConv;
          return b.confidenceScore - a.confidenceScore;
        })
        .slice(0, 10);
    }
    
    // Analyze positioning from sparkline (multi-period funding proxy)
    function analyzePositioningFromSparkline(sparkline, coin) {
      if (!sparkline || sparkline.length < 24) return null;
      
      // Split into 8 periods for funding analysis
      const periods = [];
      const periodSize = Math.floor(sparkline.length / 8);
      
      for (let i = 0; i < 8; i++) {
        const start = i * periodSize;
        const end = i === 7 ? sparkline.length : (i + 1) * periodSize;
        const periodPrices = sparkline.slice(start, end);
        const avgPrice = periodPrices.reduce((a, b) => a + b, 0) / periodPrices.length;
        const endPrice = periodPrices[periodPrices.length - 1];
        const fundingProxy = ((endPrice - avgPrice) / avgPrice) * 100;
        periods.push({ avgPrice, endPrice, fundingProxy });
      }
      
      // Count persistent positive/negative funding
      const positiveFunding = periods.filter(p => p.fundingProxy > 0.5).length;
      const negativeFunding = periods.filter(p => p.fundingProxy < -0.5).length;
      
      // Calculate persistence
      const persistence = Math.max(positiveFunding, negativeFunding);
      const fundingDirection = positiveFunding > negativeFunding ? 'positive' : 'negative';
      
      // Calculate price movement over period
      const startPrice = sparkline[0];
      const endPrice = sparkline[sparkline.length - 1];
      const priceChange = ((endPrice - startPrice) / startPrice) * 100;
      
      // Check for divergence (funding vs price)
      const fundingAligned = (fundingDirection === 'positive' && priceChange > 3) || 
                            (fundingDirection === 'negative' && priceChange < -3);
      const fundingDiverged = (fundingDirection === 'positive' && priceChange < -2) || 
                             (fundingDirection === 'negative' && priceChange > 2);
      
      // Calculate stress score (0-100)
      let stressScore = 0;
      stressScore += persistence * 8; // Up to 64
      if (fundingDiverged) stressScore += 20;
      
      // Volume ratio adds to stress
      const volumeRatio = coin.total_volume / coin.market_cap;
      if (volumeRatio > 0.1) stressScore += 15;
      else if (volumeRatio > 0.05) stressScore += 8;
      
      // 24h price position extremity
      const pricePosition = coin.high_24h && coin.low_24h 
        ? (coin.current_price - coin.low_24h) / (coin.high_24h - coin.low_24h)
        : 0.5;
      
      if (pricePosition > 0.9 || pricePosition < 0.1) stressScore += 12;
      else if (pricePosition > 0.8 || pricePosition < 0.2) stressScore += 6;
      
      return {
        fundingDirection,
        persistence,
        priceChange,
        fundingAligned,
        fundingDiverged,
        stressScore: Math.min(100, stressScore),
        pricePosition,
        volumeRatio,
        avgFunding: periods.reduce((a, p) => a + p.fundingProxy, 0) / periods.length
      };
    }
    
    // Classify trade setup (FADE, SQUEEZE, VOL_EXPANSION)
    function classifyTradeSetupFrontend(positioning, volatility, coin) {
      const { persistence, stressScore, fundingDiverged, fundingDirection, pricePosition, priceChange } = positioning;
      
      // REJECT: Insufficient data
      if (persistence < 3) {
        return { valid: false, reason: 'Insufficient persistence' };
      }
      
      // REJECT: Low stress
      if (stressScore < 30) {
        return { valid: false, reason: 'Low positioning stress' };
      }
      
      // VOL_EXPANSION: Compressed volatility with position buildup
      if (volatility.compression < 0.6 && stressScore > 45) {
        return {
          valid: true,
          tradeType: 'VOL_EXPANSION',
          direction: fundingDirection === 'positive' ? 'LONG' : 'SHORT',
          conviction: stressScore > 65 ? 'HIGH' : 'MEDIUM',
          rationale: 'Volatility compression with positioning buildup - breakout imminent'
        };
      }
      
      // FADE_TRADE: Crowded positioning at price extreme
      if (persistence >= 5 && (pricePosition > 0.85 || pricePosition < 0.15)) {
        const fadeLong = pricePosition < 0.15 && fundingDirection === 'negative';
        const fadeShort = pricePosition > 0.85 && fundingDirection === 'positive';
        
        if (fadeLong || fadeShort) {
          return {
            valid: true,
            tradeType: 'FADE_TRADE',
            direction: fadeLong ? 'LONG' : 'SHORT',
            conviction: persistence >= 6 && stressScore > 55 ? 'HIGH' : 'MEDIUM',
            rationale: `Crowded ${fadeLong ? 'shorts' : 'longs'} at price extreme - mean reversion setup`
          };
        }
      }
      
      // SQUEEZE_SETUP: High leverage with divergent price action
      if (fundingDiverged && stressScore > 50) {
        const squeezeDirection = fundingDirection === 'positive' ? 'SHORT' : 'LONG';
        return {
          valid: true,
          tradeType: 'SQUEEZE_SETUP',
          direction: squeezeDirection,
          conviction: stressScore > 70 ? 'HIGH' : 'MEDIUM',
          rationale: `${fundingDirection === 'positive' ? 'Longs' : 'Shorts'} offside - funding/price divergence indicates squeeze potential`
        };
      }
      
      return { valid: false, reason: 'No clear trade setup' };
    }
    
    // Generate positioning-based signal
    function generatePositioningSignalFrontend(coin, positioning, tradeSetup, sparkline) {
      const { tradeType, direction, conviction, rationale } = tradeSetup;
      const symbol = coin.symbol.toUpperCase();
      
      const min7d = Math.min(...sparkline.slice(-24));
      const max7d = Math.max(...sparkline.slice(-24));
      
      let tradeExpression, invalidation, timeHorizon;
      
      switch (tradeType) {
        case 'FADE_TRADE':
          tradeExpression = direction === 'LONG'
            ? `Fade shorts: Long ${symbol} with stop below recent low. Target: return to 7d VWAP (~$${formatNumber((max7d + min7d) / 2)})`
            : `Fade longs: Short ${symbol} with stop above recent high. Target: return to 7d VWAP (~$${formatNumber((max7d + min7d) / 2)})`;
          invalidation = direction === 'LONG'
            ? `New low below $${formatNumber(min7d * 0.98)}`
            : `New high above $${formatNumber(max7d * 1.02)}`;
          timeHorizon = '4-24 hours';
          break;
          
        case 'SQUEEZE_SETUP':
          tradeExpression = direction === 'LONG'
            ? `Long ${symbol} on short squeeze. Entry: $${formatNumber(coin.current_price)}. Target: +8-12% as shorts cover.`
            : `Short ${symbol} on long liquidation cascade. Target: -8-12% as longs capitulate.`;
          invalidation = direction === 'LONG'
            ? `Price drops below $${formatNumber(min7d * 0.95)}`
            : `Price breaks above $${formatNumber(max7d * 1.05)}`;
          timeHorizon = '12-48 hours';
          break;
          
        case 'VOL_EXPANSION':
          tradeExpression = direction === 'LONG'
            ? `Long ${symbol} volatility expansion. Buy breakout above $${formatNumber(max7d)}. Target: 5-10% move on vol release.`
            : `Short ${symbol} on breakdown below $${formatNumber(min7d)}. Target: 5-10% downside on vol release.`;
          invalidation = direction === 'LONG'
            ? `False breakout - rejection back below $${formatNumber(max7d * 0.98)}`
            : `False breakdown - recovery above $${formatNumber(min7d * 1.02)}`;
          timeHorizon = '24-72 hours';
          break;
      }
      
      // Calculate confidence
      let confidence = 40;
      confidence += Math.min(20, positioning.persistence * 3);
      confidence += Math.min(15, positioning.stressScore / 5);
      if (positioning.fundingDiverged) confidence += 10;
      if (conviction === 'HIGH') confidence += 5;
      
      return {
        signalType: tradeType,
        tradeType: tradeType,
        asset: symbol,
        direction,
        conviction,
        marketContext: `${symbol} at $${formatNumber(coin.current_price)}. 7d: ${positioning.priceChange > 0 ? '+' : ''}${positioning.priceChange.toFixed(1)}%. 24h range: $${formatNumber(coin.low_24h)} - $${formatNumber(coin.high_24h)}. Vol/MCap: ${(positioning.volumeRatio * 100).toFixed(1)}%.`,
        observedAnomaly: `${rationale}. Positioning stress: ${positioning.stressScore}/100. Funding persistence: ${positioning.persistence}/8 periods ${positioning.fundingDirection}.`,
        whyMatters: tradeType === 'FADE_TRADE' 
          ? 'Crowded positioning at extremes creates mean-reversion opportunity. Funding costs and liquidation risk force position unwind.'
          : tradeType === 'SQUEEZE_SETUP'
            ? 'Price diverging from positioning suggests trapped traders. Liquidation cascade likely when stops trigger.'
            : 'Volatility compression with position buildup creates explosive breakout potential. Stored energy ready to release.',
        tradeExpression,
        timeHorizon,
        keyRisks: tradeType === 'FADE_TRADE'
          ? 'Trend continuation, news catalyst, funding can remain extreme longer than expected'
          : tradeType === 'SQUEEZE_SETUP'
            ? 'False signal, whale positioning unknown, exchange-specific dynamics'
            : 'False breakout/breakdown, liquidity gaps, market-wide correlation',
        invalidationLevel: invalidation,
        confidenceScore: Math.min(80, confidence),
        timestamp: new Date().toISOString(),
        rawData: {
          price: coin.current_price,
          priceChange7d: positioning.priceChange,
          stressScore: positioning.stressScore,
          persistence: positioning.persistence,
          fundingDirection: positioning.fundingDirection
        }
      };
    }

    // Calculate volatility from sparkline
    function calculateSparklineVolatility(prices) {
      if (!prices || prices.length < 2) return 0;
      const returns = [];
      for (let i = 1; i < prices.length; i++) {
        returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
      }
      const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
      const variance = returns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / returns.length;
      return Math.sqrt(variance);
    }

    // Format numbers for display
    function formatNumber(num) {
      if (!num) return '0';
      if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
      if (num < 1) return num.toFixed(6);
      return num.toFixed(2);
    }

    // Format timestamp for display
    function formatTimestamp(isoString) {
      const date = new Date(isoString);
      const now = new Date();
      const diffMs = now - date;
      const diffSecs = Math.floor(diffMs / 1000);
      const diffMins = Math.floor(diffSecs / 60);
      
      if (diffSecs < 60) return 'just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      return date.toLocaleTimeString();
    }

    // Demo signals (last resort fallback) - showcasing all signal types
    function generateDemoSignals() {
      return [
        {
          signalType: 'FADE_TRADE',
          tradeType: 'FADE_TRADE',
          asset: 'ETH',
          direction: 'SHORT',
          conviction: 'HIGH',
          marketContext: 'ETH at $3,450. 7d: +12.3%. 24h range: $3,380 - $3,470. Vol/MCap: 8.2%. Price at 92% of 24h range.',
          observedAnomaly: 'Crowded longs at price extreme - mean reversion setup. Positioning stress: 72/100. Funding persistence: 6/8 periods positive.',
          whyMatters: '[DEMO] Crowded positioning at extremes creates mean-reversion opportunity. Funding costs and liquidation risk force position unwind.',
          tradeExpression: 'Fade longs: Short ETH with stop above recent high. Target: return to 7d VWAP (~$3,400)',
          timeHorizon: '4-24 hours',
          keyRisks: '[DEMO] Trend continuation, news catalyst, funding can remain extreme longer than expected',
          invalidationLevel: 'New high above $3,540',
          confidenceScore: 68,
          timestamp: new Date().toISOString()
        },
        {
          signalType: 'SQUEEZE_SETUP',
          tradeType: 'SQUEEZE_SETUP',
          asset: 'SOL',
          direction: 'LONG',
          conviction: 'MEDIUM',
          marketContext: 'SOL at $178. 7d: -4.2%. 24h range: $175 - $182. Vol/MCap: 11.5%. Funding persistently negative despite price holding.',
          observedAnomaly: 'Shorts offside - funding/price divergence indicates squeeze potential. Positioning stress: 58/100. Funding persistence: 5/8 periods negative.',
          whyMatters: '[DEMO] Price diverging from positioning suggests trapped traders. Liquidation cascade likely when stops trigger.',
          tradeExpression: 'Long SOL on short squeeze. Entry: $178. Target: +8-12% as shorts cover.',
          timeHorizon: '12-48 hours',
          keyRisks: '[DEMO] False signal, whale positioning unknown, exchange-specific dynamics',
          invalidationLevel: 'Price drops below $168',
          confidenceScore: 62,
          timestamp: new Date().toISOString()
        },
        {
          signalType: 'VOL_EXPANSION',
          tradeType: 'VOL_EXPANSION',
          asset: 'BTC',
          direction: 'LONG',
          conviction: 'MEDIUM',
          marketContext: 'BTC at $97,500. 7d: +1.2%. Volatility compression: 0.52x normal. Vol/MCap: 5.8%. Range-bound for 5 days.',
          observedAnomaly: 'Volatility compression with positioning buildup - breakout imminent. Positioning stress: 55/100. Funding persistence: 4/8 periods positive.',
          whyMatters: '[DEMO] Volatility compression with position buildup creates explosive breakout potential. Stored energy ready to release.',
          tradeExpression: 'Long BTC volatility expansion. Buy breakout above $98,200. Target: 5-10% move on vol release.',
          timeHorizon: '24-72 hours',
          keyRisks: '[DEMO] False breakout/breakdown, liquidity gaps, market-wide correlation',
          invalidationLevel: 'False breakout - rejection back below $97,000',
          confidenceScore: 56,
          timestamp: new Date().toISOString()
        },
        {
          signalType: 'TVL_LAG',
          tradeType: 'TVL_LAG',
          asset: 'Pendle (PENDLE)',
          direction: 'LONG',
          conviction: 'HIGH',
          marketContext: 'Pendle TVL: $4.2B. 7d TVL change: +18.4%. Token price 7d: +3.2%. TVL/MCap ratio: 6.8x.',
          observedAnomaly: 'TVL growth (+18.4%) significantly outpacing token appreciation (+3.2%). Divergence: 15.2%.',
          whyMatters: '[DEMO] Capital flowing into protocol but token price lagging. Connect to live API for real signals.',
          tradeExpression: 'Long PENDLE spot. Entry: current. Target: 12-15% catch-up move.',
          timeHorizon: '1-2 weeks',
          keyRisks: '[DEMO] Mercenary TVL, token inflation, smart contract risk',
          invalidationLevel: 'TVL drops >10%',
          confidenceScore: 72,
          timestamp: new Date().toISOString()
        }
      ];
    }

    // Filter signals by type (supports both tradeType and signalType)
    function filterSignals(type) {
      currentFilter = type;
      
      // Update button states
      document.querySelectorAll('.scanner-btn[data-type]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
      });
      
      const filtered = type === 'all' 
        ? allAlphaSignals 
        : allAlphaSignals.filter(s => {
            const tradeType = (s.tradeType || '').toLowerCase();
            const signalType = (s.signalType || '').toLowerCase();
            return tradeType === type || signalType === type;
          });
      
      renderSignals(filtered);
    }

    // Render signal cards
    function renderSignals(signals) {
      const container = document.getElementById('alphaSignals');
      
      if (signals.length === 0) {
        container.innerHTML = `
          <div class="no-signals">
            <div class="no-signals-icon">üîç</div>
            <p>No actionable signals detected</p>
            <p style="font-size: 0.8rem; margin-top: 8px;">Markets appear range-bound with no significant anomalies</p>
          </div>
        `;
        return;
      }
      
      container.innerHTML = signals.map((signal, idx) => {
        const confClass = signal.confidenceScore >= 60 ? 'high' : signal.confidenceScore >= 40 ? 'medium' : 'low';
        const typeClass = getTradeTypeClass(signal);
        const signalTime = signal.timestamp ? formatTimestamp(signal.timestamp) : 'just now';
        const displayType = signal.tradeType || signal.signalType;
        const convictionBadge = getConvictionBadge(signal.conviction);
        const directionIcon = signal.direction === 'LONG' ? 'üìà' : signal.direction === 'SHORT' ? 'üìâ' : '';
        
        return `
          <div class="signal-card" data-signal-id="${idx}">
            <div class="signal-header">
              <div>
                <span class="signal-type-badge ${typeClass}">${formatSignalType(displayType)}</span>
                ${convictionBadge}
                <div class="signal-asset" style="margin-top: 6px;">${directionIcon} ${signal.asset}</div>
              </div>
              <div class="confidence-meter">
                <span class="signal-timestamp" style="font-size: 0.7rem; color: #475569; margin-right: 8px;">${signalTime}</span>
                <div class="confidence-bar">
                  <div class="confidence-fill ${confClass}" style="width: ${signal.confidenceScore}%;"></div>
                </div>
                <span class="confidence-score">${signal.confidenceScore}%</span>
              </div>
            </div>
            
            <div class="signal-context">${signal.marketContext}</div>
            
            <div class="signal-section">
              <div class="signal-section-title">Observed Anomaly</div>
              <div class="signal-section-content">${signal.observedAnomaly}</div>
            </div>
            
            <div class="trade-expression">
              <div class="signal-section-title">Trade Expression</div>
              <div class="signal-section-content">${signal.tradeExpression}</div>
            </div>
            
            <div class="signal-meta">
              <div class="meta-item">
                <span class="meta-label">Time Horizon</span>
                <span class="meta-value">${signal.timeHorizon}</span>
              </div>
              <div class="meta-item">
                <span class="meta-label">Invalidation</span>
                <span class="meta-value invalidation">${signal.invalidationLevel}</span>
              </div>
            </div>
            
            <button class="signal-expand-btn" onclick="toggleSignalDetails(${idx})">
              Show full analysis ‚ñº
            </button>
            
            <div class="signal-details" id="signal-details-${idx}">
              <div class="signal-section">
                <div class="signal-section-title">Why This Matters</div>
                <div class="signal-section-content">${signal.whyMatters}</div>
              </div>
              <div class="signal-section">
                <div class="signal-section-title">Key Risks</div>
                <div class="signal-section-content meta-value risk">${signal.keyRisks}</div>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Toggle signal details
    function toggleSignalDetails(idx) {
      const details = document.getElementById(`signal-details-${idx}`);
      const btn = details.previousElementSibling;
      
      if (details.classList.contains('expanded')) {
        details.classList.remove('expanded');
        btn.textContent = 'Show full analysis ‚ñº';
      } else {
        details.classList.add('expanded');
        btn.textContent = 'Hide analysis ‚ñ≤';
      }
    }

    // Format signal type for display
    function formatSignalType(type) {
      const types = {
        'OI_DIVERGENCE': 'OI Divergence',
        'TVL_LAG': 'TVL Lag',
        'FUNDING_DIVERGENCE': 'Funding',
        'FADE_TRADE': 'Fade Trade',
        'SQUEEZE_SETUP': 'Squeeze Setup',
        'VOL_EXPANSION': 'Vol Expansion',
        'POSITIONING': 'Positioning'
      };
      return types[type] || type.replace(/_/g, ' ');
    }
    
    // Get trade type class for styling
    function getTradeTypeClass(signal) {
      // Prefer tradeType if available, otherwise use signalType
      const type = signal.tradeType || signal.signalType;
      return type.toLowerCase();
    }
    
    // Get conviction badge HTML
    function getConvictionBadge(conviction) {
      if (!conviction) return '';
      const level = conviction.toLowerCase();
      return `<span class="conviction-badge ${level}">${conviction}</span>`;
    }

    // Setup auto-refresh
    function setupAutoRefresh() {
      if (refreshInterval) clearInterval(refreshInterval);
      
      refreshInterval = setInterval(() => {
        runAlphaScan();
        loadInsights();
        loadNews();
        loadTrending();
      }, AUTO_REFRESH_MS);
    }

    // Initialize on load
    setupAutoRefresh();
  </script>
  
  <!-- Wallet Connection Module -->
  <script src="js/walletConnect.js"></script>
  
  <script>
    // Portfolio Health Score Integration
    let userAssets = [];

    // Calculate portfolio health score
    function calculateHealthScore(assets) {
      if (!assets || assets.length === 0) return 0;

      let score = 30; // Base score
      
      const hasStables = assets.some(a => ['USDT', 'USDC', 'DAI', 'BUSD'].includes(a.symbol));
      const hasEth = assets.some(a => a.symbol === 'ETH');
      
      // Diversity bonus
      if (assets.length >= 2) score += 20;
      if (assets.length >= 3) score += 10;
      if (assets.length >= 4) score += 10;
      
      // Stablecoin presence
      if (hasStables) score += 15;
      
      // ETH presence
      if (hasEth) score += 15;

      return Math.min(100, score);
    }

    // Update portfolio health UI
    function updatePortfolioHealth() {
      const healthScore = calculateHealthScore(userAssets);
      const healthScoreEl = document.getElementById('healthScore');
      const portfolioHealthEl = document.getElementById('portfolioHealth');
      const walletState = window.WalletConnect ? window.WalletConnect.getState() : null;

      if (healthScoreEl && portfolioHealthEl && walletState) {
        healthScoreEl.textContent = healthScore + '/100';
        
        if (healthScore >= 70) {
          healthScoreEl.style.color = '#22c55e';
        } else if (healthScore >= 40) {
          healthScoreEl.style.color = '#fbbf24';
        } else {
          healthScoreEl.style.color = '#ef4444';
        }
        
        portfolioHealthEl.style.display = walletState.address ? 'block' : 'none';
      }
    }

    // Load wallet assets for health score
    async function loadWalletAssetsForHealth() {
      const walletState = window.WalletConnect ? window.WalletConnect.getState() : null;
      if (!walletState || !walletState.provider || !walletState.address) return;

      try {
        userAssets = [];

        // Get ETH balance
        const ethBalance = await walletState.provider.getBalance(walletState.address);
        const ethAmount = parseFloat(ethers.utils.formatEther(ethBalance));
        
        if (ethAmount > 0) {
          userAssets.push({ symbol: 'ETH', balance: ethAmount });
        }

        // Check common tokens
        const tokens = [
          { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', symbol: 'USDT', decimals: 6 },
          { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', symbol: 'USDC', decimals: 6 },
          { address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', symbol: 'DAI', decimals: 18 },
        ];

        for (const token of tokens) {
          try {
            const contract = new ethers.Contract(
              token.address,
              ['function balanceOf(address) view returns (uint256)'],
              walletState.provider
            );
            const balance = await contract.balanceOf(walletState.address);
            const amount = parseFloat(ethers.utils.formatUnits(balance, token.decimals));
            if (amount > 0.01) {
              userAssets.push({ symbol: token.symbol, balance: amount });
            }
          } catch (err) {
            console.warn(`Failed to load ${token.symbol}`);
          }
        }

        updatePortfolioHealth();
      } catch (error) {
        console.error('Error loading assets:', error);
      }
    }

    // Listen for wallet state changes
    window.addEventListener('walletStateChanged', (e) => {
      const state = e.detail;
      if (state.status === 'connected') {
        loadWalletAssetsForHealth();
      } else {
        userAssets = [];
        updatePortfolioHealth();
      }
    });
  </script>
</body>
</html>
